/* tslint:disable */
/* eslint-disable */
/**
 * Emby Server API
 * Explore the Emby Server API
 *
 * OpenAPI spec version: 4.6.7.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { MediaEncodingApiOnPlaybackProgress } from '../models';
import { PlaybackProgressInfo } from '../models';
import { PlaybackStartInfo } from '../models';
import { PlaybackStopInfo } from '../models';
import { UserItemDataDto } from '../models';
/**
 * PlaystateServiceApi - axios parameter creator
 * @export
 */
export const PlaystateServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Requires authentication as user
         * @summary Marks an item as unplayed
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersByUseridPlayeditemsById: async (userId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUsersByUseridPlayeditemsById.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteUsersByUseridPlayeditemsById.');
            }
            const localVarPath = `/Users/{UserId}/PlayedItems/{Id}`
                .replace(`{${"UserId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports that a user has stopped playing an item
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {string} nextMediaType The next media type that will play
         * @param {number} [positionTicks] Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersByUseridPlayingitemsById: async (userId: string, id: string, mediaSourceId: string, nextMediaType: string, positionTicks?: number, liveStreamId?: string, playSessionId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUsersByUseridPlayingitemsById.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteUsersByUseridPlayingitemsById.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling deleteUsersByUseridPlayingitemsById.');
            }
            // verify required parameter 'nextMediaType' is not null or undefined
            if (nextMediaType === null || nextMediaType === undefined) {
                throw new RequiredError('nextMediaType','Required parameter nextMediaType was null or undefined when calling deleteUsersByUseridPlayingitemsById.');
            }
            const localVarPath = `/Users/{UserId}/PlayingItems/{Id}`
                .replace(`{${"UserId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['MediaSourceId'] = mediaSourceId;
            }

            if (nextMediaType !== undefined) {
                localVarQueryParameter['NextMediaType'] = nextMediaType;
            }

            if (positionTicks !== undefined) {
                localVarQueryParameter['PositionTicks'] = positionTicks;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['LiveStreamId'] = liveStreamId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['PlaySessionId'] = playSessionId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports playback has started within a session
         * @param {PlaybackStartInfo} body PlaybackStartInfo: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsPlaying: async (body: PlaybackStartInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSessionsPlaying.');
            }
            const localVarPath = `/Sessions/Playing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Pings a playback session
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsPlayingPing: async (playSessionId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Playing/Ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (playSessionId !== undefined) {
                localVarQueryParameter['PlaySessionId'] = playSessionId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports playback progress within a session
         * @param {PlaybackProgressInfo} body PlaybackProgressInfo: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsPlayingProgress: async (body: PlaybackProgressInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSessionsPlayingProgress.');
            }
            const localVarPath = `/Sessions/Playing/Progress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports playback has stopped within a session
         * @param {PlaybackStopInfo} body PlaybackStopInfo: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsPlayingStopped: async (body: PlaybackStopInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSessionsPlayingStopped.');
            }
            const localVarPath = `/Sessions/Playing/Stopped`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates userdata for an item
         * @param {UserItemDataDto} body UserItemDataDto: 
         * @param {string} userId User Id
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByUseridItemsByItemidUserdata: async (body: UserItemDataDto, userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postUsersByUseridItemsByItemidUserdata.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling postUsersByUseridItemsByItemidUserdata.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling postUsersByUseridItemsByItemidUserdata.');
            }
            const localVarPath = `/Users/{UserId}/Items/{ItemId}/UserData`
                .replace(`{${"UserId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"ItemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Marks an item as played
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} [datePlayed] The date the item was played (if any). Format &#x3D; yyyyMMddHHmmss
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByUseridPlayeditemsById: async (userId: string, id: string, datePlayed?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling postUsersByUseridPlayeditemsById.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postUsersByUseridPlayeditemsById.');
            }
            const localVarPath = `/Users/{UserId}/PlayedItems/{Id}`
                .replace(`{${"UserId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (datePlayed !== undefined) {
                localVarQueryParameter['DatePlayed'] = datePlayed;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports that a user has begun playing an item
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {boolean} [canSeek] Indicates if the client can seek
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {string} [playMethod] 
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByUseridPlayingitemsById: async (userId: string, id: string, mediaSourceId: string, canSeek?: boolean, audioStreamIndex?: number, subtitleStreamIndex?: number, playMethod?: string, liveStreamId?: string, playSessionId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling postUsersByUseridPlayingitemsById.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postUsersByUseridPlayingitemsById.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling postUsersByUseridPlayingitemsById.');
            }
            const localVarPath = `/Users/{UserId}/PlayingItems/{Id}`
                .replace(`{${"UserId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['MediaSourceId'] = mediaSourceId;
            }

            if (canSeek !== undefined) {
                localVarQueryParameter['CanSeek'] = canSeek;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['AudioStreamIndex'] = audioStreamIndex;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['SubtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (playMethod !== undefined) {
                localVarQueryParameter['PlayMethod'] = playMethod;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['LiveStreamId'] = liveStreamId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['PlaySessionId'] = playSessionId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports a user's playback progress
         * @param {MediaEncodingApiOnPlaybackProgress} body OnPlaybackProgress
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {number} [positionTicks] Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms
         * @param {boolean} [isPaused] Indicates if the player is paused.
         * @param {boolean} [isMuted] Indicates if the player is muted.
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {number} [volumeLevel] Scale of 0-100
         * @param {string} [playMethod] 
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {string} [repeatMode] 
         * @param {number} [subtitleOffset] 
         * @param {number} [playbackRate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByUseridPlayingitemsByIdProgress: async (body: MediaEncodingApiOnPlaybackProgress, mediaSourceId: string, userId: string, id: string, positionTicks?: number, isPaused?: boolean, isMuted?: boolean, audioStreamIndex?: number, subtitleStreamIndex?: number, volumeLevel?: number, playMethod?: string, liveStreamId?: string, playSessionId?: string, repeatMode?: string, subtitleOffset?: number, playbackRate?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postUsersByUseridPlayingitemsByIdProgress.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling postUsersByUseridPlayingitemsByIdProgress.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling postUsersByUseridPlayingitemsByIdProgress.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postUsersByUseridPlayingitemsByIdProgress.');
            }
            const localVarPath = `/Users/{UserId}/PlayingItems/{Id}/Progress`
                .replace(`{${"UserId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['MediaSourceId'] = mediaSourceId;
            }

            if (positionTicks !== undefined) {
                localVarQueryParameter['PositionTicks'] = positionTicks;
            }

            if (isPaused !== undefined) {
                localVarQueryParameter['IsPaused'] = isPaused;
            }

            if (isMuted !== undefined) {
                localVarQueryParameter['IsMuted'] = isMuted;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['AudioStreamIndex'] = audioStreamIndex;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['SubtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (volumeLevel !== undefined) {
                localVarQueryParameter['VolumeLevel'] = volumeLevel;
            }

            if (playMethod !== undefined) {
                localVarQueryParameter['PlayMethod'] = playMethod;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['LiveStreamId'] = liveStreamId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['PlaySessionId'] = playSessionId;
            }

            if (repeatMode !== undefined) {
                localVarQueryParameter['RepeatMode'] = repeatMode;
            }

            if (subtitleOffset !== undefined) {
                localVarQueryParameter['SubtitleOffset'] = subtitleOffset;
            }

            if (playbackRate !== undefined) {
                localVarQueryParameter['PlaybackRate'] = playbackRate;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaystateServiceApi - functional programming interface
 * @export
 */
export const PlaystateServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Requires authentication as user
         * @summary Marks an item as unplayed
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsersByUseridPlayeditemsById(userId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await PlaystateServiceApiAxiosParamCreator(configuration).deleteUsersByUseridPlayeditemsById(userId, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports that a user has stopped playing an item
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {string} nextMediaType The next media type that will play
         * @param {number} [positionTicks] Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsersByUseridPlayingitemsById(userId: string, id: string, mediaSourceId: string, nextMediaType: string, positionTicks?: number, liveStreamId?: string, playSessionId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateServiceApiAxiosParamCreator(configuration).deleteUsersByUseridPlayingitemsById(userId, id, mediaSourceId, nextMediaType, positionTicks, liveStreamId, playSessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports playback has started within a session
         * @param {PlaybackStartInfo} body PlaybackStartInfo: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsPlaying(body: PlaybackStartInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateServiceApiAxiosParamCreator(configuration).postSessionsPlaying(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Pings a playback session
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsPlayingPing(playSessionId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateServiceApiAxiosParamCreator(configuration).postSessionsPlayingPing(playSessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports playback progress within a session
         * @param {PlaybackProgressInfo} body PlaybackProgressInfo: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsPlayingProgress(body: PlaybackProgressInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateServiceApiAxiosParamCreator(configuration).postSessionsPlayingProgress(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports playback has stopped within a session
         * @param {PlaybackStopInfo} body PlaybackStopInfo: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsPlayingStopped(body: PlaybackStopInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateServiceApiAxiosParamCreator(configuration).postSessionsPlayingStopped(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates userdata for an item
         * @param {UserItemDataDto} body UserItemDataDto: 
         * @param {string} userId User Id
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersByUseridItemsByItemidUserdata(body: UserItemDataDto, userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateServiceApiAxiosParamCreator(configuration).postUsersByUseridItemsByItemidUserdata(body, userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Marks an item as played
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} [datePlayed] The date the item was played (if any). Format &#x3D; yyyyMMddHHmmss
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersByUseridPlayeditemsById(userId: string, id: string, datePlayed?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await PlaystateServiceApiAxiosParamCreator(configuration).postUsersByUseridPlayeditemsById(userId, id, datePlayed, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports that a user has begun playing an item
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {boolean} [canSeek] Indicates if the client can seek
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {string} [playMethod] 
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersByUseridPlayingitemsById(userId: string, id: string, mediaSourceId: string, canSeek?: boolean, audioStreamIndex?: number, subtitleStreamIndex?: number, playMethod?: string, liveStreamId?: string, playSessionId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateServiceApiAxiosParamCreator(configuration).postUsersByUseridPlayingitemsById(userId, id, mediaSourceId, canSeek, audioStreamIndex, subtitleStreamIndex, playMethod, liveStreamId, playSessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports a user's playback progress
         * @param {MediaEncodingApiOnPlaybackProgress} body OnPlaybackProgress
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {number} [positionTicks] Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms
         * @param {boolean} [isPaused] Indicates if the player is paused.
         * @param {boolean} [isMuted] Indicates if the player is muted.
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {number} [volumeLevel] Scale of 0-100
         * @param {string} [playMethod] 
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {string} [repeatMode] 
         * @param {number} [subtitleOffset] 
         * @param {number} [playbackRate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersByUseridPlayingitemsByIdProgress(body: MediaEncodingApiOnPlaybackProgress, mediaSourceId: string, userId: string, id: string, positionTicks?: number, isPaused?: boolean, isMuted?: boolean, audioStreamIndex?: number, subtitleStreamIndex?: number, volumeLevel?: number, playMethod?: string, liveStreamId?: string, playSessionId?: string, repeatMode?: string, subtitleOffset?: number, playbackRate?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateServiceApiAxiosParamCreator(configuration).postUsersByUseridPlayingitemsByIdProgress(body, mediaSourceId, userId, id, positionTicks, isPaused, isMuted, audioStreamIndex, subtitleStreamIndex, volumeLevel, playMethod, liveStreamId, playSessionId, repeatMode, subtitleOffset, playbackRate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PlaystateServiceApi - factory interface
 * @export
 */
export const PlaystateServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Requires authentication as user
         * @summary Marks an item as unplayed
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersByUseridPlayeditemsById(userId: string, id: string, options?: any): AxiosPromise<UserItemDataDto> {
            return PlaystateServiceApiFp(configuration).deleteUsersByUseridPlayeditemsById(userId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Reports that a user has stopped playing an item
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {string} nextMediaType The next media type that will play
         * @param {number} [positionTicks] Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersByUseridPlayingitemsById(userId: string, id: string, mediaSourceId: string, nextMediaType: string, positionTicks?: number, liveStreamId?: string, playSessionId?: string, options?: any): AxiosPromise<void> {
            return PlaystateServiceApiFp(configuration).deleteUsersByUseridPlayingitemsById(userId, id, mediaSourceId, nextMediaType, positionTicks, liveStreamId, playSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Reports playback has started within a session
         * @param {PlaybackStartInfo} body PlaybackStartInfo: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsPlaying(body: PlaybackStartInfo, options?: any): AxiosPromise<void> {
            return PlaystateServiceApiFp(configuration).postSessionsPlaying(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Pings a playback session
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsPlayingPing(playSessionId?: string, options?: any): AxiosPromise<void> {
            return PlaystateServiceApiFp(configuration).postSessionsPlayingPing(playSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Reports playback progress within a session
         * @param {PlaybackProgressInfo} body PlaybackProgressInfo: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsPlayingProgress(body: PlaybackProgressInfo, options?: any): AxiosPromise<void> {
            return PlaystateServiceApiFp(configuration).postSessionsPlayingProgress(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Reports playback has stopped within a session
         * @param {PlaybackStopInfo} body PlaybackStopInfo: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsPlayingStopped(body: PlaybackStopInfo, options?: any): AxiosPromise<void> {
            return PlaystateServiceApiFp(configuration).postSessionsPlayingStopped(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Updates userdata for an item
         * @param {UserItemDataDto} body UserItemDataDto: 
         * @param {string} userId User Id
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByUseridItemsByItemidUserdata(body: UserItemDataDto, userId: string, itemId: string, options?: any): AxiosPromise<void> {
            return PlaystateServiceApiFp(configuration).postUsersByUseridItemsByItemidUserdata(body, userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Marks an item as played
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} [datePlayed] The date the item was played (if any). Format &#x3D; yyyyMMddHHmmss
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByUseridPlayeditemsById(userId: string, id: string, datePlayed?: string, options?: any): AxiosPromise<UserItemDataDto> {
            return PlaystateServiceApiFp(configuration).postUsersByUseridPlayeditemsById(userId, id, datePlayed, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Reports that a user has begun playing an item
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {boolean} [canSeek] Indicates if the client can seek
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {string} [playMethod] 
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByUseridPlayingitemsById(userId: string, id: string, mediaSourceId: string, canSeek?: boolean, audioStreamIndex?: number, subtitleStreamIndex?: number, playMethod?: string, liveStreamId?: string, playSessionId?: string, options?: any): AxiosPromise<void> {
            return PlaystateServiceApiFp(configuration).postUsersByUseridPlayingitemsById(userId, id, mediaSourceId, canSeek, audioStreamIndex, subtitleStreamIndex, playMethod, liveStreamId, playSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Reports a user's playback progress
         * @param {MediaEncodingApiOnPlaybackProgress} body OnPlaybackProgress
         * @param {string} mediaSourceId The id of the MediaSource
         * @param {string} userId User Id
         * @param {string} id Item Id
         * @param {number} [positionTicks] Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms
         * @param {boolean} [isPaused] Indicates if the player is paused.
         * @param {boolean} [isMuted] Indicates if the player is muted.
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {number} [volumeLevel] Scale of 0-100
         * @param {string} [playMethod] 
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {string} [repeatMode] 
         * @param {number} [subtitleOffset] 
         * @param {number} [playbackRate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByUseridPlayingitemsByIdProgress(body: MediaEncodingApiOnPlaybackProgress, mediaSourceId: string, userId: string, id: string, positionTicks?: number, isPaused?: boolean, isMuted?: boolean, audioStreamIndex?: number, subtitleStreamIndex?: number, volumeLevel?: number, playMethod?: string, liveStreamId?: string, playSessionId?: string, repeatMode?: string, subtitleOffset?: number, playbackRate?: number, options?: any): AxiosPromise<void> {
            return PlaystateServiceApiFp(configuration).postUsersByUseridPlayingitemsByIdProgress(body, mediaSourceId, userId, id, positionTicks, isPaused, isMuted, audioStreamIndex, subtitleStreamIndex, volumeLevel, playMethod, liveStreamId, playSessionId, repeatMode, subtitleOffset, playbackRate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaystateServiceApi - object-oriented interface
 * @export
 * @class PlaystateServiceApi
 * @extends {BaseAPI}
 */
export class PlaystateServiceApi extends BaseAPI {
    /**
     * Requires authentication as user
     * @summary Marks an item as unplayed
     * @param {string} userId User Id
     * @param {string} id Item Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    public deleteUsersByUseridPlayeditemsById(userId: string, id: string, options?: any) {
        return PlaystateServiceApiFp(this.configuration).deleteUsersByUseridPlayeditemsById(userId, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Reports that a user has stopped playing an item
     * @param {string} userId User Id
     * @param {string} id Item Id
     * @param {string} mediaSourceId The id of the MediaSource
     * @param {string} nextMediaType The next media type that will play
     * @param {number} [positionTicks] Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms
     * @param {string} [liveStreamId] 
     * @param {string} [playSessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    public deleteUsersByUseridPlayingitemsById(userId: string, id: string, mediaSourceId: string, nextMediaType: string, positionTicks?: number, liveStreamId?: string, playSessionId?: string, options?: any) {
        return PlaystateServiceApiFp(this.configuration).deleteUsersByUseridPlayingitemsById(userId, id, mediaSourceId, nextMediaType, positionTicks, liveStreamId, playSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Reports playback has started within a session
     * @param {PlaybackStartInfo} body PlaybackStartInfo: 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    public postSessionsPlaying(body: PlaybackStartInfo, options?: any) {
        return PlaystateServiceApiFp(this.configuration).postSessionsPlaying(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Pings a playback session
     * @param {string} [playSessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    public postSessionsPlayingPing(playSessionId?: string, options?: any) {
        return PlaystateServiceApiFp(this.configuration).postSessionsPlayingPing(playSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Reports playback progress within a session
     * @param {PlaybackProgressInfo} body PlaybackProgressInfo: 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    public postSessionsPlayingProgress(body: PlaybackProgressInfo, options?: any) {
        return PlaystateServiceApiFp(this.configuration).postSessionsPlayingProgress(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Reports playback has stopped within a session
     * @param {PlaybackStopInfo} body PlaybackStopInfo: 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    public postSessionsPlayingStopped(body: PlaybackStopInfo, options?: any) {
        return PlaystateServiceApiFp(this.configuration).postSessionsPlayingStopped(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Updates userdata for an item
     * @param {UserItemDataDto} body UserItemDataDto: 
     * @param {string} userId User Id
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    public postUsersByUseridItemsByItemidUserdata(body: UserItemDataDto, userId: string, itemId: string, options?: any) {
        return PlaystateServiceApiFp(this.configuration).postUsersByUseridItemsByItemidUserdata(body, userId, itemId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Marks an item as played
     * @param {string} userId User Id
     * @param {string} id Item Id
     * @param {string} [datePlayed] The date the item was played (if any). Format &#x3D; yyyyMMddHHmmss
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    public postUsersByUseridPlayeditemsById(userId: string, id: string, datePlayed?: string, options?: any) {
        return PlaystateServiceApiFp(this.configuration).postUsersByUseridPlayeditemsById(userId, id, datePlayed, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Reports that a user has begun playing an item
     * @param {string} userId User Id
     * @param {string} id Item Id
     * @param {string} mediaSourceId The id of the MediaSource
     * @param {boolean} [canSeek] Indicates if the client can seek
     * @param {number} [audioStreamIndex] 
     * @param {number} [subtitleStreamIndex] 
     * @param {string} [playMethod] 
     * @param {string} [liveStreamId] 
     * @param {string} [playSessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    public postUsersByUseridPlayingitemsById(userId: string, id: string, mediaSourceId: string, canSeek?: boolean, audioStreamIndex?: number, subtitleStreamIndex?: number, playMethod?: string, liveStreamId?: string, playSessionId?: string, options?: any) {
        return PlaystateServiceApiFp(this.configuration).postUsersByUseridPlayingitemsById(userId, id, mediaSourceId, canSeek, audioStreamIndex, subtitleStreamIndex, playMethod, liveStreamId, playSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Reports a user's playback progress
     * @param {MediaEncodingApiOnPlaybackProgress} body OnPlaybackProgress
     * @param {string} mediaSourceId The id of the MediaSource
     * @param {string} userId User Id
     * @param {string} id Item Id
     * @param {number} [positionTicks] Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms
     * @param {boolean} [isPaused] Indicates if the player is paused.
     * @param {boolean} [isMuted] Indicates if the player is muted.
     * @param {number} [audioStreamIndex] 
     * @param {number} [subtitleStreamIndex] 
     * @param {number} [volumeLevel] Scale of 0-100
     * @param {string} [playMethod] 
     * @param {string} [liveStreamId] 
     * @param {string} [playSessionId] 
     * @param {string} [repeatMode] 
     * @param {number} [subtitleOffset] 
     * @param {number} [playbackRate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateServiceApi
     */
    public postUsersByUseridPlayingitemsByIdProgress(body: MediaEncodingApiOnPlaybackProgress, mediaSourceId: string, userId: string, id: string, positionTicks?: number, isPaused?: boolean, isMuted?: boolean, audioStreamIndex?: number, subtitleStreamIndex?: number, volumeLevel?: number, playMethod?: string, liveStreamId?: string, playSessionId?: string, repeatMode?: string, subtitleOffset?: number, playbackRate?: number, options?: any) {
        return PlaystateServiceApiFp(this.configuration).postUsersByUseridPlayingitemsByIdProgress(body, mediaSourceId, userId, id, positionTicks, isPaused, isMuted, audioStreamIndex, subtitleStreamIndex, volumeLevel, playMethod, liveStreamId, playSessionId, repeatMode, subtitleOffset, playbackRate, options).then((request) => request(this.axios, this.basePath));
    }
}
