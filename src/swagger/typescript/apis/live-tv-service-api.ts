/* tslint:disable */
/* eslint-disable */
/**
 * Emby Server API
 * Explore the Emby Server API
 *
 * OpenAPI spec version: 4.6.7.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { BaseItemDto } from '../models';
import { LiveTVApiGetPrograms } from '../models';
import { LiveTVApiListingProviderTypeInfo } from '../models';
import { LiveTVApiSetChannelDisabled } from '../models';
import { LiveTVApiSetChannelMapping } from '../models';
import { LiveTVApiSetChannelSortIndex } from '../models';
import { LiveTVApiTagItem } from '../models';
import { LiveTvGuideInfo } from '../models';
import { LiveTvListingsProviderInfo } from '../models';
import { LiveTvLiveTvInfo } from '../models';
import { LiveTvSeriesTimerInfoDto } from '../models';
import { LiveTvTimerInfoDto } from '../models';
import { LiveTvTunerHostInfo } from '../models';
import { NameIdPair } from '../models';
import { QueryResultBaseItemDto } from '../models';
import { QueryResultEmbyLiveTVChannelManagementInfo } from '../models';
import { QueryResultLiveTVApiEpgRow } from '../models';
import { QueryResultLiveTvSeriesTimerInfoDto } from '../models';
import { QueryResultLiveTvTimerInfoDto } from '../models';
/**
 * LiveTvServiceApi - axios parameter creator
 * @export
 */
export const LiveTvServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvChannelmappingoptions: async (providerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId','Required parameter providerId was null or undefined when calling deleteLivetvChannelmappingoptions.');
            }
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (providerId !== undefined) {
                localVarQueryParameter['ProviderId'] = providerId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvChannelmappings: async (providerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId','Required parameter providerId was null or undefined when calling deleteLivetvChannelmappings.');
            }
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (providerId !== undefined) {
                localVarQueryParameter['ProviderId'] = providerId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Deletes a listing provider
         * @param {string} [id] Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvListingproviders: async (id?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (id !== undefined) {
                localVarQueryParameter['Id'] = id;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Deletes a live tv recording
         * @param {string} id Recording Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvRecordingsById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLivetvRecordingsById.');
            }
            const localVarPath = `/LiveTv/Recordings/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Cancels a live tv series timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvSeriestimersById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLivetvSeriestimersById.');
            }
            const localVarPath = `/LiveTv/SeriesTimers/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Cancels a live tv timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvTimersById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLivetvTimersById.');
            }
            const localVarPath = `/LiveTv/Timers/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Deletes a tuner host
         * @param {string} [id] Tuner host id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvTunerhosts: async (id?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (id !== undefined) {
                localVarQueryParameter['Id'] = id;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChannelmappingoptions: async (providerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId','Required parameter providerId was null or undefined when calling getLivetvChannelmappingoptions.');
            }
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (providerId !== undefined) {
                localVarQueryParameter['ProviderId'] = providerId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChannelmappings: async (providerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId','Required parameter providerId was null or undefined when calling getLivetvChannelmappings.');
            }
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (providerId !== undefined) {
                localVarQueryParameter['ProviderId'] = providerId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv channels.
         * @param {string} [type] Optional filter by channel type.
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isFavorite] Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Filter by channels that are disliked, or not.
         * @param {boolean} [enableFavoriteSorting] Incorporate favorite and like status into channel sorting.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChannels: async (type?: string, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableFavoriteSorting?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, addCurrentProgram?: boolean, enableUserData?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (type !== undefined) {
                localVarQueryParameter['Type'] = type;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['StartIndex'] = startIndex;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['IsMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['IsSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['IsNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['IsKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['IsSports'] = isSports;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['IsFavorite'] = isFavorite;
            }

            if (isLiked !== undefined) {
                localVarQueryParameter['IsLiked'] = isLiked;
            }

            if (isDisliked !== undefined) {
                localVarQueryParameter['IsDisliked'] = isDisliked;
            }

            if (enableFavoriteSorting !== undefined) {
                localVarQueryParameter['EnableFavoriteSorting'] = enableFavoriteSorting;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['EnableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['ImageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['EnableImageTypes'] = enableImageTypes;
            }

            if (fields !== undefined) {
                localVarQueryParameter['Fields'] = fields;
            }

            if (addCurrentProgram !== undefined) {
                localVarQueryParameter['AddCurrentProgram'] = addCurrentProgram;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['EnableUserData'] = enableUserData;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv channel
         * @param {string} id Channel Id
         * @param {string} [userId] Optional attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChannelsById: async (id: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLivetvChannelsById.');
            }
            const localVarPath = `/LiveTv/Channels/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @summary Gets live tv channel tags
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChanneltags: async (artistType?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, minIndexNumber?: number, minPlayers?: number, maxPlayers?: number, parentIndexNumber?: number, hasParentalRating?: boolean, isHD?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, airedDuringSeason?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, anyProviderIdEquals?: string, filters?: string, isFavorite?: boolean, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, artists?: string, artistIds?: string, albums?: string, ids?: string, videoTypes?: string, containers?: string, audioCodecs?: string, videoCodecs?: string, subtitleCodecs?: string, path?: string, userId?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, groupItemsIntoCollections?: boolean, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ChannelTags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (artistType !== undefined) {
                localVarQueryParameter['ArtistType'] = artistType;
            }

            if (maxOfficialRating !== undefined) {
                localVarQueryParameter['MaxOfficialRating'] = maxOfficialRating;
            }

            if (hasThemeSong !== undefined) {
                localVarQueryParameter['HasThemeSong'] = hasThemeSong;
            }

            if (hasThemeVideo !== undefined) {
                localVarQueryParameter['HasThemeVideo'] = hasThemeVideo;
            }

            if (hasSubtitles !== undefined) {
                localVarQueryParameter['HasSubtitles'] = hasSubtitles;
            }

            if (hasSpecialFeature !== undefined) {
                localVarQueryParameter['HasSpecialFeature'] = hasSpecialFeature;
            }

            if (hasTrailer !== undefined) {
                localVarQueryParameter['HasTrailer'] = hasTrailer;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['AdjacentTo'] = adjacentTo;
            }

            if (minIndexNumber !== undefined) {
                localVarQueryParameter['MinIndexNumber'] = minIndexNumber;
            }

            if (minPlayers !== undefined) {
                localVarQueryParameter['MinPlayers'] = minPlayers;
            }

            if (maxPlayers !== undefined) {
                localVarQueryParameter['MaxPlayers'] = maxPlayers;
            }

            if (parentIndexNumber !== undefined) {
                localVarQueryParameter['ParentIndexNumber'] = parentIndexNumber;
            }

            if (hasParentalRating !== undefined) {
                localVarQueryParameter['HasParentalRating'] = hasParentalRating;
            }

            if (isHD !== undefined) {
                localVarQueryParameter['IsHD'] = isHD;
            }

            if (locationTypes !== undefined) {
                localVarQueryParameter['LocationTypes'] = locationTypes;
            }

            if (excludeLocationTypes !== undefined) {
                localVarQueryParameter['ExcludeLocationTypes'] = excludeLocationTypes;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['IsMissing'] = isMissing;
            }

            if (isUnaired !== undefined) {
                localVarQueryParameter['IsUnaired'] = isUnaired;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['MinCommunityRating'] = minCommunityRating;
            }

            if (minCriticRating !== undefined) {
                localVarQueryParameter['MinCriticRating'] = minCriticRating;
            }

            if (airedDuringSeason !== undefined) {
                localVarQueryParameter['AiredDuringSeason'] = airedDuringSeason;
            }

            if (minPremiereDate !== undefined) {
                localVarQueryParameter['MinPremiereDate'] = minPremiereDate;
            }

            if (minDateLastSaved !== undefined) {
                localVarQueryParameter['MinDateLastSaved'] = minDateLastSaved;
            }

            if (minDateLastSavedForUser !== undefined) {
                localVarQueryParameter['MinDateLastSavedForUser'] = minDateLastSavedForUser;
            }

            if (maxPremiereDate !== undefined) {
                localVarQueryParameter['MaxPremiereDate'] = maxPremiereDate;
            }

            if (hasOverview !== undefined) {
                localVarQueryParameter['HasOverview'] = hasOverview;
            }

            if (hasImdbId !== undefined) {
                localVarQueryParameter['HasImdbId'] = hasImdbId;
            }

            if (hasTmdbId !== undefined) {
                localVarQueryParameter['HasTmdbId'] = hasTmdbId;
            }

            if (hasTvdbId !== undefined) {
                localVarQueryParameter['HasTvdbId'] = hasTvdbId;
            }

            if (excludeItemIds !== undefined) {
                localVarQueryParameter['ExcludeItemIds'] = excludeItemIds;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['StartIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['Recursive'] = recursive;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['SearchTerm'] = searchTerm;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['SortOrder'] = sortOrder;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['ParentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['Fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['ExcludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['IncludeItemTypes'] = includeItemTypes;
            }

            if (anyProviderIdEquals !== undefined) {
                localVarQueryParameter['AnyProviderIdEquals'] = anyProviderIdEquals;
            }

            if (filters !== undefined) {
                localVarQueryParameter['Filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['IsFavorite'] = isFavorite;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['IsMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['IsSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['IsNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['IsKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['IsSports'] = isSports;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['MediaTypes'] = mediaTypes;
            }

            if (imageTypes !== undefined) {
                localVarQueryParameter['ImageTypes'] = imageTypes;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (isPlayed !== undefined) {
                localVarQueryParameter['IsPlayed'] = isPlayed;
            }

            if (genres !== undefined) {
                localVarQueryParameter['Genres'] = genres;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['OfficialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['Tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['Years'] = years;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['EnableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['EnableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['ImageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['EnableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['Person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['PersonIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['PersonTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['Studios'] = studios;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['StudioIds'] = studioIds;
            }

            if (artists !== undefined) {
                localVarQueryParameter['Artists'] = artists;
            }

            if (artistIds !== undefined) {
                localVarQueryParameter['ArtistIds'] = artistIds;
            }

            if (albums !== undefined) {
                localVarQueryParameter['Albums'] = albums;
            }

            if (ids !== undefined) {
                localVarQueryParameter['Ids'] = ids;
            }

            if (videoTypes !== undefined) {
                localVarQueryParameter['VideoTypes'] = videoTypes;
            }

            if (containers !== undefined) {
                localVarQueryParameter['Containers'] = containers;
            }

            if (audioCodecs !== undefined) {
                localVarQueryParameter['AudioCodecs'] = audioCodecs;
            }

            if (videoCodecs !== undefined) {
                localVarQueryParameter['VideoCodecs'] = videoCodecs;
            }

            if (subtitleCodecs !== undefined) {
                localVarQueryParameter['SubtitleCodecs'] = subtitleCodecs;
            }

            if (path !== undefined) {
                localVarQueryParameter['Path'] = path;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (minOfficialRating !== undefined) {
                localVarQueryParameter['MinOfficialRating'] = minOfficialRating;
            }

            if (isLocked !== undefined) {
                localVarQueryParameter['IsLocked'] = isLocked;
            }

            if (isPlaceHolder !== undefined) {
                localVarQueryParameter['IsPlaceHolder'] = isPlaceHolder;
            }

            if (hasOfficialRating !== undefined) {
                localVarQueryParameter['HasOfficialRating'] = hasOfficialRating;
            }

            if (groupItemsIntoCollections !== undefined) {
                localVarQueryParameter['GroupItemsIntoCollections'] = groupItemsIntoCollections;
            }

            if (is3D !== undefined) {
                localVarQueryParameter['Is3D'] = is3D;
            }

            if (seriesStatus !== undefined) {
                localVarQueryParameter['SeriesStatus'] = seriesStatus;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['NameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['NameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['NameLessThan'] = nameLessThan;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @summary Gets live tv channel tag prefixes
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChanneltagsPrefixes: async (artistType?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, minIndexNumber?: number, minPlayers?: number, maxPlayers?: number, parentIndexNumber?: number, hasParentalRating?: boolean, isHD?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, airedDuringSeason?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, anyProviderIdEquals?: string, filters?: string, isFavorite?: boolean, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, artists?: string, artistIds?: string, albums?: string, ids?: string, videoTypes?: string, containers?: string, audioCodecs?: string, videoCodecs?: string, subtitleCodecs?: string, path?: string, userId?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, groupItemsIntoCollections?: boolean, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ChannelTags/Prefixes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (artistType !== undefined) {
                localVarQueryParameter['ArtistType'] = artistType;
            }

            if (maxOfficialRating !== undefined) {
                localVarQueryParameter['MaxOfficialRating'] = maxOfficialRating;
            }

            if (hasThemeSong !== undefined) {
                localVarQueryParameter['HasThemeSong'] = hasThemeSong;
            }

            if (hasThemeVideo !== undefined) {
                localVarQueryParameter['HasThemeVideo'] = hasThemeVideo;
            }

            if (hasSubtitles !== undefined) {
                localVarQueryParameter['HasSubtitles'] = hasSubtitles;
            }

            if (hasSpecialFeature !== undefined) {
                localVarQueryParameter['HasSpecialFeature'] = hasSpecialFeature;
            }

            if (hasTrailer !== undefined) {
                localVarQueryParameter['HasTrailer'] = hasTrailer;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['AdjacentTo'] = adjacentTo;
            }

            if (minIndexNumber !== undefined) {
                localVarQueryParameter['MinIndexNumber'] = minIndexNumber;
            }

            if (minPlayers !== undefined) {
                localVarQueryParameter['MinPlayers'] = minPlayers;
            }

            if (maxPlayers !== undefined) {
                localVarQueryParameter['MaxPlayers'] = maxPlayers;
            }

            if (parentIndexNumber !== undefined) {
                localVarQueryParameter['ParentIndexNumber'] = parentIndexNumber;
            }

            if (hasParentalRating !== undefined) {
                localVarQueryParameter['HasParentalRating'] = hasParentalRating;
            }

            if (isHD !== undefined) {
                localVarQueryParameter['IsHD'] = isHD;
            }

            if (locationTypes !== undefined) {
                localVarQueryParameter['LocationTypes'] = locationTypes;
            }

            if (excludeLocationTypes !== undefined) {
                localVarQueryParameter['ExcludeLocationTypes'] = excludeLocationTypes;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['IsMissing'] = isMissing;
            }

            if (isUnaired !== undefined) {
                localVarQueryParameter['IsUnaired'] = isUnaired;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['MinCommunityRating'] = minCommunityRating;
            }

            if (minCriticRating !== undefined) {
                localVarQueryParameter['MinCriticRating'] = minCriticRating;
            }

            if (airedDuringSeason !== undefined) {
                localVarQueryParameter['AiredDuringSeason'] = airedDuringSeason;
            }

            if (minPremiereDate !== undefined) {
                localVarQueryParameter['MinPremiereDate'] = minPremiereDate;
            }

            if (minDateLastSaved !== undefined) {
                localVarQueryParameter['MinDateLastSaved'] = minDateLastSaved;
            }

            if (minDateLastSavedForUser !== undefined) {
                localVarQueryParameter['MinDateLastSavedForUser'] = minDateLastSavedForUser;
            }

            if (maxPremiereDate !== undefined) {
                localVarQueryParameter['MaxPremiereDate'] = maxPremiereDate;
            }

            if (hasOverview !== undefined) {
                localVarQueryParameter['HasOverview'] = hasOverview;
            }

            if (hasImdbId !== undefined) {
                localVarQueryParameter['HasImdbId'] = hasImdbId;
            }

            if (hasTmdbId !== undefined) {
                localVarQueryParameter['HasTmdbId'] = hasTmdbId;
            }

            if (hasTvdbId !== undefined) {
                localVarQueryParameter['HasTvdbId'] = hasTvdbId;
            }

            if (excludeItemIds !== undefined) {
                localVarQueryParameter['ExcludeItemIds'] = excludeItemIds;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['StartIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['Recursive'] = recursive;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['SearchTerm'] = searchTerm;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['SortOrder'] = sortOrder;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['ParentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['Fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['ExcludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['IncludeItemTypes'] = includeItemTypes;
            }

            if (anyProviderIdEquals !== undefined) {
                localVarQueryParameter['AnyProviderIdEquals'] = anyProviderIdEquals;
            }

            if (filters !== undefined) {
                localVarQueryParameter['Filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['IsFavorite'] = isFavorite;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['IsMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['IsSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['IsNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['IsKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['IsSports'] = isSports;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['MediaTypes'] = mediaTypes;
            }

            if (imageTypes !== undefined) {
                localVarQueryParameter['ImageTypes'] = imageTypes;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (isPlayed !== undefined) {
                localVarQueryParameter['IsPlayed'] = isPlayed;
            }

            if (genres !== undefined) {
                localVarQueryParameter['Genres'] = genres;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['OfficialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['Tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['Years'] = years;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['EnableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['EnableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['ImageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['EnableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['Person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['PersonIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['PersonTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['Studios'] = studios;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['StudioIds'] = studioIds;
            }

            if (artists !== undefined) {
                localVarQueryParameter['Artists'] = artists;
            }

            if (artistIds !== undefined) {
                localVarQueryParameter['ArtistIds'] = artistIds;
            }

            if (albums !== undefined) {
                localVarQueryParameter['Albums'] = albums;
            }

            if (ids !== undefined) {
                localVarQueryParameter['Ids'] = ids;
            }

            if (videoTypes !== undefined) {
                localVarQueryParameter['VideoTypes'] = videoTypes;
            }

            if (containers !== undefined) {
                localVarQueryParameter['Containers'] = containers;
            }

            if (audioCodecs !== undefined) {
                localVarQueryParameter['AudioCodecs'] = audioCodecs;
            }

            if (videoCodecs !== undefined) {
                localVarQueryParameter['VideoCodecs'] = videoCodecs;
            }

            if (subtitleCodecs !== undefined) {
                localVarQueryParameter['SubtitleCodecs'] = subtitleCodecs;
            }

            if (path !== undefined) {
                localVarQueryParameter['Path'] = path;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (minOfficialRating !== undefined) {
                localVarQueryParameter['MinOfficialRating'] = minOfficialRating;
            }

            if (isLocked !== undefined) {
                localVarQueryParameter['IsLocked'] = isLocked;
            }

            if (isPlaceHolder !== undefined) {
                localVarQueryParameter['IsPlaceHolder'] = isPlaceHolder;
            }

            if (hasOfficialRating !== undefined) {
                localVarQueryParameter['HasOfficialRating'] = hasOfficialRating;
            }

            if (groupItemsIntoCollections !== undefined) {
                localVarQueryParameter['GroupItemsIntoCollections'] = groupItemsIntoCollections;
            }

            if (is3D !== undefined) {
                localVarQueryParameter['Is3D'] = is3D;
            }

            if (seriesStatus !== undefined) {
                localVarQueryParameter['SeriesStatus'] = seriesStatus;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['NameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['NameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['NameLessThan'] = nameLessThan;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets the epg.
         * @param {string} [type] Optional filter by channel type.
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isFavorite] Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Filter by channels that are disliked, or not.
         * @param {boolean} [enableFavoriteSorting] Incorporate favorite and like status into channel sorting.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvEPG: async (type?: string, userId?: string, genreIds?: string, minStartDate?: string, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableFavoriteSorting?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, addCurrentProgram?: boolean, enableUserData?: boolean, channelIds?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/EPG`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (type !== undefined) {
                localVarQueryParameter['Type'] = type;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['GenreIds'] = genreIds;
            }

            if (minStartDate !== undefined) {
                localVarQueryParameter['MinStartDate'] = minStartDate;
            }

            if (maxStartDate !== undefined) {
                localVarQueryParameter['MaxStartDate'] = maxStartDate;
            }

            if (minEndDate !== undefined) {
                localVarQueryParameter['MinEndDate'] = minEndDate;
            }

            if (maxEndDate !== undefined) {
                localVarQueryParameter['MaxEndDate'] = maxEndDate;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['StartIndex'] = startIndex;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['IsMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['IsSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['IsNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['IsKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['IsSports'] = isSports;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['IsFavorite'] = isFavorite;
            }

            if (isLiked !== undefined) {
                localVarQueryParameter['IsLiked'] = isLiked;
            }

            if (isDisliked !== undefined) {
                localVarQueryParameter['IsDisliked'] = isDisliked;
            }

            if (enableFavoriteSorting !== undefined) {
                localVarQueryParameter['EnableFavoriteSorting'] = enableFavoriteSorting;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['EnableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['ImageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['EnableImageTypes'] = enableImageTypes;
            }

            if (fields !== undefined) {
                localVarQueryParameter['Fields'] = fields;
            }

            if (addCurrentProgram !== undefined) {
                localVarQueryParameter['AddCurrentProgram'] = addCurrentProgram;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['EnableUserData'] = enableUserData;
            }

            if (channelIds !== undefined) {
                localVarQueryParameter['ChannelIds'] = channelIds;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets the top level live tv folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvFolder: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets guide info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvGuideinfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/GuideInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets current listing providers
         * @param {string} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingproviders: async (channelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling getLivetvListingproviders.');
            }
            const localVarPath = `/LiveTv/ListingProviders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (channelId !== undefined) {
                localVarQueryParameter['ChannelId'] = channelId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets listing provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingprovidersAvailable: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/Available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingprovidersDefault: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/Default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets available lineups
         * @param {string} [id] Provider id
         * @param {string} [type] Provider Type
         * @param {string} [location] Location
         * @param {string} [country] Country
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingprovidersLineups: async (id?: string, type?: string, location?: string, country?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/Lineups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (id !== undefined) {
                localVarQueryParameter['Id'] = id;
            }

            if (type !== undefined) {
                localVarQueryParameter['Type'] = type;
            }

            if (location !== undefined) {
                localVarQueryParameter['Location'] = location;
            }

            if (country !== undefined) {
                localVarQueryParameter['Country'] = country;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets available lineups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingprovidersSchedulesdirectCountries: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/SchedulesDirect/Countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @summary Gets a live tv channel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvLiverecordingsByIdStream: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLivetvLiverecordingsByIdStream.');
            }
            const localVarPath = `/LiveTv/LiveRecordings/{Id}/stream`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @summary Gets a live tv channel
         * @param {string} id 
         * @param {string} container 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvLivestreamfilesByIdByContainer: async (id: string, container: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLivetvLivestreamfilesByIdByContainer.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getLivetvLivestreamfilesByIdByContainer.');
            }
            const localVarPath = `/LiveTv/LiveStreamFiles/{Id}/stream.{Container}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets the channel management list
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvManageChannels: async (startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Manage/Channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (startIndex !== undefined) {
                localVarQueryParameter['StartIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['SortOrder'] = sortOrder;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional filter by user id.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvPrograms: async (channelIds?: string, userId?: string, hasAired?: boolean, minStartDate?: string, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, genreIds?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, fields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Programs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (channelIds !== undefined) {
                localVarQueryParameter['ChannelIds'] = channelIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (hasAired !== undefined) {
                localVarQueryParameter['HasAired'] = hasAired;
            }

            if (minStartDate !== undefined) {
                localVarQueryParameter['MinStartDate'] = minStartDate;
            }

            if (maxStartDate !== undefined) {
                localVarQueryParameter['MaxStartDate'] = maxStartDate;
            }

            if (minEndDate !== undefined) {
                localVarQueryParameter['MinEndDate'] = minEndDate;
            }

            if (maxEndDate !== undefined) {
                localVarQueryParameter['MaxEndDate'] = maxEndDate;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['IsMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['IsSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['IsNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['IsKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['IsSports'] = isSports;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['StartIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['SortOrder'] = sortOrder;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['GenreIds'] = genreIds;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['EnableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['ImageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['EnableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['EnableUserData'] = enableUserData;
            }

            if (fields !== undefined) {
                localVarQueryParameter['Fields'] = fields;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {string} [userId] Optional filter by user id.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvProgramsRecommended: async (userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, genreIds?: string, fields?: string, enableUserData?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Programs/Recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (isAiring !== undefined) {
                localVarQueryParameter['IsAiring'] = isAiring;
            }

            if (hasAired !== undefined) {
                localVarQueryParameter['HasAired'] = hasAired;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['IsSeries'] = isSeries;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['IsMovie'] = isMovie;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['IsNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['IsKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['IsSports'] = isSports;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['EnableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['ImageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['EnableImageTypes'] = enableImageTypes;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['GenreIds'] = genreIds;
            }

            if (fields !== undefined) {
                localVarQueryParameter['Fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['EnableUserData'] = enableUserData;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recordings
         * @param {string} [channelId] Optional filter by channel id.
         * @param {string} [status] Optional filter by recording status.
         * @param {boolean} [isInProgress] Optional filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional filter by recordings belonging to a series timer
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordings: async (channelId?: string, status?: string, isInProgress?: boolean, seriesTimerId?: string, artistType?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, minIndexNumber?: number, minPlayers?: number, maxPlayers?: number, parentIndexNumber?: number, hasParentalRating?: boolean, isHD?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, airedDuringSeason?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, anyProviderIdEquals?: string, filters?: string, isFavorite?: boolean, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, artists?: string, artistIds?: string, albums?: string, ids?: string, videoTypes?: string, containers?: string, audioCodecs?: string, videoCodecs?: string, subtitleCodecs?: string, path?: string, userId?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, groupItemsIntoCollections?: boolean, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (channelId !== undefined) {
                localVarQueryParameter['ChannelId'] = channelId;
            }

            if (status !== undefined) {
                localVarQueryParameter['Status'] = status;
            }

            if (isInProgress !== undefined) {
                localVarQueryParameter['IsInProgress'] = isInProgress;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['SeriesTimerId'] = seriesTimerId;
            }

            if (artistType !== undefined) {
                localVarQueryParameter['ArtistType'] = artistType;
            }

            if (maxOfficialRating !== undefined) {
                localVarQueryParameter['MaxOfficialRating'] = maxOfficialRating;
            }

            if (hasThemeSong !== undefined) {
                localVarQueryParameter['HasThemeSong'] = hasThemeSong;
            }

            if (hasThemeVideo !== undefined) {
                localVarQueryParameter['HasThemeVideo'] = hasThemeVideo;
            }

            if (hasSubtitles !== undefined) {
                localVarQueryParameter['HasSubtitles'] = hasSubtitles;
            }

            if (hasSpecialFeature !== undefined) {
                localVarQueryParameter['HasSpecialFeature'] = hasSpecialFeature;
            }

            if (hasTrailer !== undefined) {
                localVarQueryParameter['HasTrailer'] = hasTrailer;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['AdjacentTo'] = adjacentTo;
            }

            if (minIndexNumber !== undefined) {
                localVarQueryParameter['MinIndexNumber'] = minIndexNumber;
            }

            if (minPlayers !== undefined) {
                localVarQueryParameter['MinPlayers'] = minPlayers;
            }

            if (maxPlayers !== undefined) {
                localVarQueryParameter['MaxPlayers'] = maxPlayers;
            }

            if (parentIndexNumber !== undefined) {
                localVarQueryParameter['ParentIndexNumber'] = parentIndexNumber;
            }

            if (hasParentalRating !== undefined) {
                localVarQueryParameter['HasParentalRating'] = hasParentalRating;
            }

            if (isHD !== undefined) {
                localVarQueryParameter['IsHD'] = isHD;
            }

            if (locationTypes !== undefined) {
                localVarQueryParameter['LocationTypes'] = locationTypes;
            }

            if (excludeLocationTypes !== undefined) {
                localVarQueryParameter['ExcludeLocationTypes'] = excludeLocationTypes;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['IsMissing'] = isMissing;
            }

            if (isUnaired !== undefined) {
                localVarQueryParameter['IsUnaired'] = isUnaired;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['MinCommunityRating'] = minCommunityRating;
            }

            if (minCriticRating !== undefined) {
                localVarQueryParameter['MinCriticRating'] = minCriticRating;
            }

            if (airedDuringSeason !== undefined) {
                localVarQueryParameter['AiredDuringSeason'] = airedDuringSeason;
            }

            if (minPremiereDate !== undefined) {
                localVarQueryParameter['MinPremiereDate'] = minPremiereDate;
            }

            if (minDateLastSaved !== undefined) {
                localVarQueryParameter['MinDateLastSaved'] = minDateLastSaved;
            }

            if (minDateLastSavedForUser !== undefined) {
                localVarQueryParameter['MinDateLastSavedForUser'] = minDateLastSavedForUser;
            }

            if (maxPremiereDate !== undefined) {
                localVarQueryParameter['MaxPremiereDate'] = maxPremiereDate;
            }

            if (hasOverview !== undefined) {
                localVarQueryParameter['HasOverview'] = hasOverview;
            }

            if (hasImdbId !== undefined) {
                localVarQueryParameter['HasImdbId'] = hasImdbId;
            }

            if (hasTmdbId !== undefined) {
                localVarQueryParameter['HasTmdbId'] = hasTmdbId;
            }

            if (hasTvdbId !== undefined) {
                localVarQueryParameter['HasTvdbId'] = hasTvdbId;
            }

            if (excludeItemIds !== undefined) {
                localVarQueryParameter['ExcludeItemIds'] = excludeItemIds;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['StartIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['Recursive'] = recursive;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['SearchTerm'] = searchTerm;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['SortOrder'] = sortOrder;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['ParentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['Fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['ExcludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['IncludeItemTypes'] = includeItemTypes;
            }

            if (anyProviderIdEquals !== undefined) {
                localVarQueryParameter['AnyProviderIdEquals'] = anyProviderIdEquals;
            }

            if (filters !== undefined) {
                localVarQueryParameter['Filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['IsFavorite'] = isFavorite;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['IsMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['IsSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['IsNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['IsKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['IsSports'] = isSports;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['MediaTypes'] = mediaTypes;
            }

            if (imageTypes !== undefined) {
                localVarQueryParameter['ImageTypes'] = imageTypes;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (isPlayed !== undefined) {
                localVarQueryParameter['IsPlayed'] = isPlayed;
            }

            if (genres !== undefined) {
                localVarQueryParameter['Genres'] = genres;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['OfficialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['Tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['Years'] = years;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['EnableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['EnableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['ImageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['EnableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['Person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['PersonIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['PersonTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['Studios'] = studios;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['StudioIds'] = studioIds;
            }

            if (artists !== undefined) {
                localVarQueryParameter['Artists'] = artists;
            }

            if (artistIds !== undefined) {
                localVarQueryParameter['ArtistIds'] = artistIds;
            }

            if (albums !== undefined) {
                localVarQueryParameter['Albums'] = albums;
            }

            if (ids !== undefined) {
                localVarQueryParameter['Ids'] = ids;
            }

            if (videoTypes !== undefined) {
                localVarQueryParameter['VideoTypes'] = videoTypes;
            }

            if (containers !== undefined) {
                localVarQueryParameter['Containers'] = containers;
            }

            if (audioCodecs !== undefined) {
                localVarQueryParameter['AudioCodecs'] = audioCodecs;
            }

            if (videoCodecs !== undefined) {
                localVarQueryParameter['VideoCodecs'] = videoCodecs;
            }

            if (subtitleCodecs !== undefined) {
                localVarQueryParameter['SubtitleCodecs'] = subtitleCodecs;
            }

            if (path !== undefined) {
                localVarQueryParameter['Path'] = path;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (minOfficialRating !== undefined) {
                localVarQueryParameter['MinOfficialRating'] = minOfficialRating;
            }

            if (isLocked !== undefined) {
                localVarQueryParameter['IsLocked'] = isLocked;
            }

            if (isPlaceHolder !== undefined) {
                localVarQueryParameter['IsPlaceHolder'] = isPlaceHolder;
            }

            if (hasOfficialRating !== undefined) {
                localVarQueryParameter['HasOfficialRating'] = hasOfficialRating;
            }

            if (groupItemsIntoCollections !== undefined) {
                localVarQueryParameter['GroupItemsIntoCollections'] = groupItemsIntoCollections;
            }

            if (is3D !== undefined) {
                localVarQueryParameter['Is3D'] = is3D;
            }

            if (seriesStatus !== undefined) {
                localVarQueryParameter['SeriesStatus'] = seriesStatus;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['NameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['NameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['NameLessThan'] = nameLessThan;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv recording
         * @param {string} id Recording Id
         * @param {string} [userId] Optional attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordingsById: async (id: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLivetvRecordingsById.');
            }
            const localVarPath = `/LiveTv/Recordings/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets recording folders
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordingsFolders: async (userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recording groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordingsGroups: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recordings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordingsSeries: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv series timers
         * @param {string} [sortBy] Optional. Sort by SortName or Priority
         * @param {string} [sortOrder] Optional. Sort in Ascending or Descending order
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvSeriestimers: async (sortBy?: string, sortOrder?: string, startIndex?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/SeriesTimers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (sortBy !== undefined) {
                localVarQueryParameter['SortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['SortOrder'] = sortOrder;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['StartIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv series timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvSeriestimersById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLivetvSeriestimersById.');
            }
            const localVarPath = `/LiveTv/SeriesTimers/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv timers
         * @param {string} [channelId] Optional filter by channel id.
         * @param {string} [seriesTimerId] Optional filter by timers belonging to a series timer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTimers: async (channelId?: string, seriesTimerId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Timers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (channelId !== undefined) {
                localVarQueryParameter['ChannelId'] = channelId;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['SeriesTimerId'] = seriesTimerId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTimersById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLivetvTimersById.');
            }
            const localVarPath = `/LiveTv/Timers/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets default values for a new timer
         * @param {string} [programId] Optional, to attach default values based on a program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTimersDefaults: async (programId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Timers/Defaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (programId !== undefined) {
                localVarQueryParameter['ProgramId'] = programId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets tuner hosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTunerhosts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTunerhostsTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts/Types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTunersDiscvover: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Tuners/Discvover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headLivetvChannelmappingoptions: async (providerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId','Required parameter providerId was null or undefined when calling headLivetvChannelmappingoptions.');
            }
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (providerId !== undefined) {
                localVarQueryParameter['ProviderId'] = providerId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headLivetvChannelmappings: async (providerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId','Required parameter providerId was null or undefined when calling headLivetvChannelmappings.');
            }
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (providerId !== undefined) {
                localVarQueryParameter['ProviderId'] = providerId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsLivetvChannelmappingoptions: async (providerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId','Required parameter providerId was null or undefined when calling optionsLivetvChannelmappingoptions.');
            }
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (providerId !== undefined) {
                localVarQueryParameter['ProviderId'] = providerId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsLivetvChannelmappings: async (providerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId','Required parameter providerId was null or undefined when calling optionsLivetvChannelmappings.');
            }
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (providerId !== undefined) {
                localVarQueryParameter['ProviderId'] = providerId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchLivetvChannelmappingoptions: async (providerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId','Required parameter providerId was null or undefined when calling patchLivetvChannelmappingoptions.');
            }
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (providerId !== undefined) {
                localVarQueryParameter['ProviderId'] = providerId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchLivetvChannelmappings: async (providerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId','Required parameter providerId was null or undefined when calling patchLivetvChannelmappings.');
            }
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (providerId !== undefined) {
                localVarQueryParameter['ProviderId'] = providerId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvChannelmappingoptions: async (providerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId','Required parameter providerId was null or undefined when calling postLivetvChannelmappingoptions.');
            }
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (providerId !== undefined) {
                localVarQueryParameter['ProviderId'] = providerId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {LiveTVApiSetChannelMapping} body SetChannelMapping
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvChannelmappings: async (body: LiveTVApiSetChannelMapping, providerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postLivetvChannelmappings.');
            }
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId','Required parameter providerId was null or undefined when calling postLivetvChannelmappings.');
            }
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (providerId !== undefined) {
                localVarQueryParameter['ProviderId'] = providerId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Adds a listing provider
         * @param {LiveTvListingsProviderInfo} body ListingsProviderInfo: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvListingproviders: async (body: LiveTvListingsProviderInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postLivetvListingproviders.');
            }
            const localVarPath = `/LiveTv/ListingProviders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Sets a channel disabled or not
         * @param {LiveTVApiSetChannelDisabled} body SetChannelDisabled
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvManageChannelsByIdDisabled: async (body: LiveTVApiSetChannelDisabled, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postLivetvManageChannelsByIdDisabled.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postLivetvManageChannelsByIdDisabled.');
            }
            const localVarPath = `/LiveTv/Manage/Channels/{Id}/Disabled`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Sets a channel sort index
         * @param {LiveTVApiSetChannelSortIndex} body SetChannelSortIndex
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvManageChannelsByIdSortindex: async (body: LiveTVApiSetChannelSortIndex, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postLivetvManageChannelsByIdSortindex.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postLivetvManageChannelsByIdSortindex.');
            }
            const localVarPath = `/LiveTv/Manage/Channels/{Id}/SortIndex`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {LiveTVApiGetPrograms} body GetPrograms
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional filter by user id.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvPrograms: async (body: LiveTVApiGetPrograms, channelIds?: string, userId?: string, minStartDate?: string, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, genreIds?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postLivetvPrograms.');
            }
            const localVarPath = `/LiveTv/Programs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (channelIds !== undefined) {
                localVarQueryParameter['ChannelIds'] = channelIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (minStartDate !== undefined) {
                localVarQueryParameter['MinStartDate'] = minStartDate;
            }

            if (maxStartDate !== undefined) {
                localVarQueryParameter['MaxStartDate'] = maxStartDate;
            }

            if (minEndDate !== undefined) {
                localVarQueryParameter['MinEndDate'] = minEndDate;
            }

            if (maxEndDate !== undefined) {
                localVarQueryParameter['MaxEndDate'] = maxEndDate;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['IsMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['IsSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['IsNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['IsKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['IsSports'] = isSports;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['GenreIds'] = genreIds;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Creates a live tv series timer
         * @param {LiveTvSeriesTimerInfoDto} body SeriesTimerInfoDto: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvSeriestimers: async (body: LiveTvSeriesTimerInfoDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postLivetvSeriestimers.');
            }
            const localVarPath = `/LiveTv/SeriesTimers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates a live tv series timer
         * @param {LiveTvSeriesTimerInfoDto} body SeriesTimerInfoDto: 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvSeriestimersById: async (body: LiveTvSeriesTimerInfoDto, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postLivetvSeriestimersById.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postLivetvSeriestimersById.');
            }
            const localVarPath = `/LiveTv/SeriesTimers/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Creates a live tv timer
         * @param {LiveTvTimerInfoDto} body TimerInfoDto: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvTimers: async (body: LiveTvTimerInfoDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postLivetvTimers.');
            }
            const localVarPath = `/LiveTv/Timers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates a live tv timer
         * @param {LiveTvTimerInfoDto} body TimerInfoDto: 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvTimersById: async (body: LiveTvTimerInfoDto, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postLivetvTimersById.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postLivetvTimersById.');
            }
            const localVarPath = `/LiveTv/Timers/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Adds a tuner host
         * @param {LiveTvTunerHostInfo} body TunerHostInfo: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvTunerhosts: async (body: LiveTvTunerHostInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postLivetvTunerhosts.');
            }
            const localVarPath = `/LiveTv/TunerHosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Resets a tv tuner
         * @param {string} id Tuner Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvTunersByIdReset: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postLivetvTunersByIdReset.');
            }
            const localVarPath = `/LiveTv/Tuners/{Id}/Reset`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLivetvChannelmappingoptions: async (providerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId','Required parameter providerId was null or undefined when calling putLivetvChannelmappingoptions.');
            }
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (providerId !== undefined) {
                localVarQueryParameter['ProviderId'] = providerId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {LiveTVApiSetChannelMapping} body SetChannelMapping
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLivetvChannelmappings: async (body: LiveTVApiSetChannelMapping, providerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putLivetvChannelmappings.');
            }
            // verify required parameter 'providerId' is not null or undefined
            if (providerId === null || providerId === undefined) {
                throw new RequiredError('providerId','Required parameter providerId was null or undefined when calling putLivetvChannelmappings.');
            }
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (providerId !== undefined) {
                localVarQueryParameter['ProviderId'] = providerId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiveTvServiceApi - functional programming interface
 * @export
 */
export const LiveTvServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLivetvChannelmappingoptions(providerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).deleteLivetvChannelmappingoptions(providerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLivetvChannelmappings(providerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).deleteLivetvChannelmappings(providerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Deletes a listing provider
         * @param {string} [id] Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLivetvListingproviders(id?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).deleteLivetvListingproviders(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Deletes a live tv recording
         * @param {string} id Recording Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLivetvRecordingsById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).deleteLivetvRecordingsById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Cancels a live tv series timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLivetvSeriestimersById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).deleteLivetvSeriestimersById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Cancels a live tv timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLivetvTimersById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).deleteLivetvTimersById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Deletes a tuner host
         * @param {string} [id] Tuner host id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLivetvTunerhosts(id?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).deleteLivetvTunerhosts(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvChannelmappingoptions(providerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvChannelmappingoptions(providerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvChannelmappings(providerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvChannelmappings(providerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv channels.
         * @param {string} [type] Optional filter by channel type.
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isFavorite] Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Filter by channels that are disliked, or not.
         * @param {boolean} [enableFavoriteSorting] Incorporate favorite and like status into channel sorting.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvChannels(type?: string, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableFavoriteSorting?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, addCurrentProgram?: boolean, enableUserData?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultBaseItemDto>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv channel
         * @param {string} id Channel Id
         * @param {string} [userId] Optional attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvChannelsById(id: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvChannelsById(id, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @summary Gets live tv channel tags
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvChanneltags(artistType?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, minIndexNumber?: number, minPlayers?: number, maxPlayers?: number, parentIndexNumber?: number, hasParentalRating?: boolean, isHD?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, airedDuringSeason?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, anyProviderIdEquals?: string, filters?: string, isFavorite?: boolean, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, artists?: string, artistIds?: string, albums?: string, ids?: string, videoTypes?: string, containers?: string, audioCodecs?: string, videoCodecs?: string, subtitleCodecs?: string, path?: string, userId?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, groupItemsIntoCollections?: boolean, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultBaseItemDto>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvChanneltags(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @summary Gets live tv channel tag prefixes
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvChanneltagsPrefixes(artistType?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, minIndexNumber?: number, minPlayers?: number, maxPlayers?: number, parentIndexNumber?: number, hasParentalRating?: boolean, isHD?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, airedDuringSeason?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, anyProviderIdEquals?: string, filters?: string, isFavorite?: boolean, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, artists?: string, artistIds?: string, albums?: string, ids?: string, videoTypes?: string, containers?: string, audioCodecs?: string, videoCodecs?: string, subtitleCodecs?: string, path?: string, userId?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, groupItemsIntoCollections?: boolean, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LiveTVApiTagItem>>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvChanneltagsPrefixes(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets the epg.
         * @param {string} [type] Optional filter by channel type.
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isFavorite] Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Filter by channels that are disliked, or not.
         * @param {boolean} [enableFavoriteSorting] Incorporate favorite and like status into channel sorting.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvEPG(type?: string, userId?: string, genreIds?: string, minStartDate?: string, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableFavoriteSorting?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, addCurrentProgram?: boolean, enableUserData?: boolean, channelIds?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultLiveTVApiEpgRow>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvEPG(type, userId, genreIds, minStartDate, maxStartDate, minEndDate, maxEndDate, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, channelIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets the top level live tv folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvFolder(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvFolder(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets guide info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvGuideinfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveTvGuideInfo>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvGuideinfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveTvLiveTvInfo>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets current listing providers
         * @param {string} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvListingproviders(channelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LiveTvListingsProviderInfo>>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvListingproviders(channelId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets listing provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvListingprovidersAvailable(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LiveTVApiListingProviderTypeInfo>>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvListingprovidersAvailable(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvListingprovidersDefault(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveTvListingsProviderInfo>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvListingprovidersDefault(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets available lineups
         * @param {string} [id] Provider id
         * @param {string} [type] Provider Type
         * @param {string} [location] Location
         * @param {string} [country] Country
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvListingprovidersLineups(id?: string, type?: string, location?: string, country?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvListingprovidersLineups(id, type, location, country, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets available lineups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvListingprovidersSchedulesdirectCountries(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvListingprovidersSchedulesdirectCountries(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @summary Gets a live tv channel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvLiverecordingsByIdStream(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvLiverecordingsByIdStream(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @summary Gets a live tv channel
         * @param {string} id 
         * @param {string} container 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvLivestreamfilesByIdByContainer(id: string, container: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvLivestreamfilesByIdByContainer(id, container, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets the channel management list
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvManageChannels(startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultEmbyLiveTVChannelManagementInfo>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvManageChannels(startIndex, limit, sortBy, sortOrder, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional filter by user id.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvPrograms(channelIds?: string, userId?: string, hasAired?: boolean, minStartDate?: string, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, genreIds?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultBaseItemDto>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvPrograms(channelIds, userId, hasAired, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {string} [userId] Optional filter by user id.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvProgramsRecommended(userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, genreIds?: string, fields?: string, enableUserData?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultBaseItemDto>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvProgramsRecommended(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recordings
         * @param {string} [channelId] Optional filter by channel id.
         * @param {string} [status] Optional filter by recording status.
         * @param {boolean} [isInProgress] Optional filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional filter by recordings belonging to a series timer
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvRecordings(channelId?: string, status?: string, isInProgress?: boolean, seriesTimerId?: string, artistType?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, minIndexNumber?: number, minPlayers?: number, maxPlayers?: number, parentIndexNumber?: number, hasParentalRating?: boolean, isHD?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, airedDuringSeason?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, anyProviderIdEquals?: string, filters?: string, isFavorite?: boolean, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, artists?: string, artistIds?: string, albums?: string, ids?: string, videoTypes?: string, containers?: string, audioCodecs?: string, videoCodecs?: string, subtitleCodecs?: string, path?: string, userId?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, groupItemsIntoCollections?: boolean, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvRecordings(channelId, status, isInProgress, seriesTimerId, artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv recording
         * @param {string} id Recording Id
         * @param {string} [userId] Optional attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvRecordingsById(id: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvRecordingsById(id, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets recording folders
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvRecordingsFolders(userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseItemDto>>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvRecordingsFolders(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recording groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvRecordingsGroups(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultBaseItemDto>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvRecordingsGroups(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recordings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvRecordingsSeries(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultBaseItemDto>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvRecordingsSeries(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv series timers
         * @param {string} [sortBy] Optional. Sort by SortName or Priority
         * @param {string} [sortOrder] Optional. Sort in Ascending or Descending order
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvSeriestimers(sortBy?: string, sortOrder?: string, startIndex?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultLiveTvSeriesTimerInfoDto>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvSeriestimers(sortBy, sortOrder, startIndex, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv series timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvSeriestimersById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveTvTimerInfoDto>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvSeriestimersById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv timers
         * @param {string} [channelId] Optional filter by channel id.
         * @param {string} [seriesTimerId] Optional filter by timers belonging to a series timer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvTimers(channelId?: string, seriesTimerId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultLiveTvTimerInfoDto>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvTimers(channelId, seriesTimerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvTimersById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveTvTimerInfoDto>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvTimersById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets default values for a new timer
         * @param {string} [programId] Optional, to attach default values based on a program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvTimersDefaults(programId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveTvSeriesTimerInfoDto>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvTimersDefaults(programId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets tuner hosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvTunerhosts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LiveTvTunerHostInfo>>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvTunerhosts(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvTunerhostsTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvTunerhostsTypes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivetvTunersDiscvover(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LiveTvTunerHostInfo>>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).getLivetvTunersDiscvover(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headLivetvChannelmappingoptions(providerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).headLivetvChannelmappingoptions(providerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headLivetvChannelmappings(providerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).headLivetvChannelmappings(providerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsLivetvChannelmappingoptions(providerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).optionsLivetvChannelmappingoptions(providerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optionsLivetvChannelmappings(providerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).optionsLivetvChannelmappings(providerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchLivetvChannelmappingoptions(providerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).patchLivetvChannelmappingoptions(providerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchLivetvChannelmappings(providerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).patchLivetvChannelmappings(providerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvChannelmappingoptions(providerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).postLivetvChannelmappingoptions(providerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {LiveTVApiSetChannelMapping} body SetChannelMapping
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvChannelmappings(body: LiveTVApiSetChannelMapping, providerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).postLivetvChannelmappings(body, providerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Adds a listing provider
         * @param {LiveTvListingsProviderInfo} body ListingsProviderInfo: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvListingproviders(body: LiveTvListingsProviderInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveTvListingsProviderInfo>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).postLivetvListingproviders(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Sets a channel disabled or not
         * @param {LiveTVApiSetChannelDisabled} body SetChannelDisabled
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvManageChannelsByIdDisabled(body: LiveTVApiSetChannelDisabled, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultEmbyLiveTVChannelManagementInfo>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).postLivetvManageChannelsByIdDisabled(body, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Sets a channel sort index
         * @param {LiveTVApiSetChannelSortIndex} body SetChannelSortIndex
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvManageChannelsByIdSortindex(body: LiveTVApiSetChannelSortIndex, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultEmbyLiveTVChannelManagementInfo>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).postLivetvManageChannelsByIdSortindex(body, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {LiveTVApiGetPrograms} body GetPrograms
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional filter by user id.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvPrograms(body: LiveTVApiGetPrograms, channelIds?: string, userId?: string, minStartDate?: string, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, genreIds?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultBaseItemDto>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).postLivetvPrograms(body, channelIds, userId, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, genreIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Creates a live tv series timer
         * @param {LiveTvSeriesTimerInfoDto} body SeriesTimerInfoDto: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvSeriestimers(body: LiveTvSeriesTimerInfoDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).postLivetvSeriestimers(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates a live tv series timer
         * @param {LiveTvSeriesTimerInfoDto} body SeriesTimerInfoDto: 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvSeriestimersById(body: LiveTvSeriesTimerInfoDto, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).postLivetvSeriestimersById(body, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Creates a live tv timer
         * @param {LiveTvTimerInfoDto} body TimerInfoDto: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvTimers(body: LiveTvTimerInfoDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).postLivetvTimers(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates a live tv timer
         * @param {LiveTvTimerInfoDto} body TimerInfoDto: 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvTimersById(body: LiveTvTimerInfoDto, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).postLivetvTimersById(body, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Adds a tuner host
         * @param {LiveTvTunerHostInfo} body TunerHostInfo: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvTunerhosts(body: LiveTvTunerHostInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveTvTunerHostInfo>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).postLivetvTunerhosts(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Resets a tv tuner
         * @param {string} id Tuner Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLivetvTunersByIdReset(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).postLivetvTunersByIdReset(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putLivetvChannelmappingoptions(providerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).putLivetvChannelmappingoptions(providerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {LiveTVApiSetChannelMapping} body SetChannelMapping
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putLivetvChannelmappings(body: LiveTVApiSetChannelMapping, providerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvServiceApiAxiosParamCreator(configuration).putLivetvChannelmappings(body, providerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LiveTvServiceApi - factory interface
 * @export
 */
export const LiveTvServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvChannelmappingoptions(providerId: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).deleteLivetvChannelmappingoptions(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvChannelmappings(providerId: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).deleteLivetvChannelmappings(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Deletes a listing provider
         * @param {string} [id] Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvListingproviders(id?: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).deleteLivetvListingproviders(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Deletes a live tv recording
         * @param {string} id Recording Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvRecordingsById(id: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).deleteLivetvRecordingsById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Cancels a live tv series timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvSeriestimersById(id: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).deleteLivetvSeriestimersById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Cancels a live tv timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvTimersById(id: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).deleteLivetvTimersById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Deletes a tuner host
         * @param {string} [id] Tuner host id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLivetvTunerhosts(id?: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).deleteLivetvTunerhosts(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChannelmappingoptions(providerId: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).getLivetvChannelmappingoptions(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChannelmappings(providerId: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).getLivetvChannelmappings(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv channels.
         * @param {string} [type] Optional filter by channel type.
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isFavorite] Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Filter by channels that are disliked, or not.
         * @param {boolean} [enableFavoriteSorting] Incorporate favorite and like status into channel sorting.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChannels(type?: string, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableFavoriteSorting?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, addCurrentProgram?: boolean, enableUserData?: boolean, options?: any): AxiosPromise<QueryResultBaseItemDto> {
            return LiveTvServiceApiFp(configuration).getLivetvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv channel
         * @param {string} id Channel Id
         * @param {string} [userId] Optional attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChannelsById(id: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return LiveTvServiceApiFp(configuration).getLivetvChannelsById(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @summary Gets live tv channel tags
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChanneltags(artistType?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, minIndexNumber?: number, minPlayers?: number, maxPlayers?: number, parentIndexNumber?: number, hasParentalRating?: boolean, isHD?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, airedDuringSeason?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, anyProviderIdEquals?: string, filters?: string, isFavorite?: boolean, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, artists?: string, artistIds?: string, albums?: string, ids?: string, videoTypes?: string, containers?: string, audioCodecs?: string, videoCodecs?: string, subtitleCodecs?: string, path?: string, userId?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, groupItemsIntoCollections?: boolean, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, options?: any): AxiosPromise<QueryResultBaseItemDto> {
            return LiveTvServiceApiFp(configuration).getLivetvChanneltags(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @summary Gets live tv channel tag prefixes
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvChanneltagsPrefixes(artistType?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, minIndexNumber?: number, minPlayers?: number, maxPlayers?: number, parentIndexNumber?: number, hasParentalRating?: boolean, isHD?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, airedDuringSeason?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, anyProviderIdEquals?: string, filters?: string, isFavorite?: boolean, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, artists?: string, artistIds?: string, albums?: string, ids?: string, videoTypes?: string, containers?: string, audioCodecs?: string, videoCodecs?: string, subtitleCodecs?: string, path?: string, userId?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, groupItemsIntoCollections?: boolean, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, options?: any): AxiosPromise<Array<LiveTVApiTagItem>> {
            return LiveTvServiceApiFp(configuration).getLivetvChanneltagsPrefixes(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets the epg.
         * @param {string} [type] Optional filter by channel type.
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isFavorite] Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Filter by channels that are disliked, or not.
         * @param {boolean} [enableFavoriteSorting] Incorporate favorite and like status into channel sorting.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvEPG(type?: string, userId?: string, genreIds?: string, minStartDate?: string, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableFavoriteSorting?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, addCurrentProgram?: boolean, enableUserData?: boolean, channelIds?: string, options?: any): AxiosPromise<QueryResultLiveTVApiEpgRow> {
            return LiveTvServiceApiFp(configuration).getLivetvEPG(type, userId, genreIds, minStartDate, maxStartDate, minEndDate, maxEndDate, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, channelIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets the top level live tv folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvFolder(options?: any): AxiosPromise<BaseItemDto> {
            return LiveTvServiceApiFp(configuration).getLivetvFolder(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets guide info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvGuideinfo(options?: any): AxiosPromise<LiveTvGuideInfo> {
            return LiveTvServiceApiFp(configuration).getLivetvGuideinfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvInfo(options?: any): AxiosPromise<LiveTvLiveTvInfo> {
            return LiveTvServiceApiFp(configuration).getLivetvInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Gets current listing providers
         * @param {string} channelId Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingproviders(channelId: string, options?: any): AxiosPromise<Array<LiveTvListingsProviderInfo>> {
            return LiveTvServiceApiFp(configuration).getLivetvListingproviders(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Gets listing provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingprovidersAvailable(options?: any): AxiosPromise<Array<LiveTVApiListingProviderTypeInfo>> {
            return LiveTvServiceApiFp(configuration).getLivetvListingprovidersAvailable(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingprovidersDefault(options?: any): AxiosPromise<LiveTvListingsProviderInfo> {
            return LiveTvServiceApiFp(configuration).getLivetvListingprovidersDefault(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Gets available lineups
         * @param {string} [id] Provider id
         * @param {string} [type] Provider Type
         * @param {string} [location] Location
         * @param {string} [country] Country
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingprovidersLineups(id?: string, type?: string, location?: string, country?: string, options?: any): AxiosPromise<Array<NameIdPair>> {
            return LiveTvServiceApiFp(configuration).getLivetvListingprovidersLineups(id, type, location, country, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Gets available lineups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvListingprovidersSchedulesdirectCountries(options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).getLivetvListingprovidersSchedulesdirectCountries(options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @summary Gets a live tv channel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvLiverecordingsByIdStream(id: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).getLivetvLiverecordingsByIdStream(id, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @summary Gets a live tv channel
         * @param {string} id 
         * @param {string} container 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvLivestreamfilesByIdByContainer(id: string, container: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).getLivetvLivestreamfilesByIdByContainer(id, container, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Gets the channel management list
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvManageChannels(startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, options?: any): AxiosPromise<QueryResultEmbyLiveTVChannelManagementInfo> {
            return LiveTvServiceApiFp(configuration).getLivetvManageChannels(startIndex, limit, sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional filter by user id.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvPrograms(channelIds?: string, userId?: string, hasAired?: boolean, minStartDate?: string, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, genreIds?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, fields?: string, options?: any): AxiosPromise<QueryResultBaseItemDto> {
            return LiveTvServiceApiFp(configuration).getLivetvPrograms(channelIds, userId, hasAired, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {string} [userId] Optional filter by user id.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvProgramsRecommended(userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, genreIds?: string, fields?: string, enableUserData?: boolean, options?: any): AxiosPromise<QueryResultBaseItemDto> {
            return LiveTvServiceApiFp(configuration).getLivetvProgramsRecommended(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recordings
         * @param {string} [channelId] Optional filter by channel id.
         * @param {string} [status] Optional filter by recording status.
         * @param {boolean} [isInProgress] Optional filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional filter by recordings belonging to a series timer
         * @param {string} [artistType] Artist or AlbumArtist
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [minIndexNumber] Optional filter by minimum index number.
         * @param {number} [minPlayers] Optional filter by minimum number of game players.
         * @param {number} [maxPlayers] Optional filter by maximum number of game players.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
         * @param {boolean} [isHD] Optional filter by items that are HD or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
         * @param {string} [searchTerm] Enter a search term to perform a search request
         * @param {string} [sortOrder] Sort Order - Ascending,Descending
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
         * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
         * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
         * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         * @param {string} [path] Optional filter by Path.
         * @param {string} [userId] User Id
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
         * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordings(channelId?: string, status?: string, isInProgress?: boolean, seriesTimerId?: string, artistType?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, minIndexNumber?: number, minPlayers?: number, maxPlayers?: number, parentIndexNumber?: number, hasParentalRating?: boolean, isHD?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, airedDuringSeason?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, anyProviderIdEquals?: string, filters?: string, isFavorite?: boolean, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, artists?: string, artistIds?: string, albums?: string, ids?: string, videoTypes?: string, containers?: string, audioCodecs?: string, videoCodecs?: string, subtitleCodecs?: string, path?: string, userId?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, groupItemsIntoCollections?: boolean, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).getLivetvRecordings(channelId, status, isInProgress, seriesTimerId, artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv recording
         * @param {string} id Recording Id
         * @param {string} [userId] Optional attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordingsById(id: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return LiveTvServiceApiFp(configuration).getLivetvRecordingsById(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets recording folders
         * @param {string} [userId] Optional filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordingsFolders(userId?: string, options?: any): AxiosPromise<Array<BaseItemDto>> {
            return LiveTvServiceApiFp(configuration).getLivetvRecordingsFolders(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recording groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordingsGroups(options?: any): AxiosPromise<QueryResultBaseItemDto> {
            return LiveTvServiceApiFp(configuration).getLivetvRecordingsGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv recordings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvRecordingsSeries(options?: any): AxiosPromise<QueryResultBaseItemDto> {
            return LiveTvServiceApiFp(configuration).getLivetvRecordingsSeries(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv series timers
         * @param {string} [sortBy] Optional. Sort by SortName or Priority
         * @param {string} [sortOrder] Optional. Sort in Ascending or Descending order
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvSeriestimers(sortBy?: string, sortOrder?: string, startIndex?: number, limit?: number, options?: any): AxiosPromise<QueryResultLiveTvSeriesTimerInfoDto> {
            return LiveTvServiceApiFp(configuration).getLivetvSeriestimers(sortBy, sortOrder, startIndex, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv series timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvSeriestimersById(id: string, options?: any): AxiosPromise<LiveTvTimerInfoDto> {
            return LiveTvServiceApiFp(configuration).getLivetvSeriestimersById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets live tv timers
         * @param {string} [channelId] Optional filter by channel id.
         * @param {string} [seriesTimerId] Optional filter by timers belonging to a series timer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTimers(channelId?: string, seriesTimerId?: string, options?: any): AxiosPromise<QueryResultLiveTvTimerInfoDto> {
            return LiveTvServiceApiFp(configuration).getLivetvTimers(channelId, seriesTimerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets a live tv timer
         * @param {string} id Timer Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTimersById(id: string, options?: any): AxiosPromise<LiveTvTimerInfoDto> {
            return LiveTvServiceApiFp(configuration).getLivetvTimersById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets default values for a new timer
         * @param {string} [programId] Optional, to attach default values based on a program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTimersDefaults(programId?: string, options?: any): AxiosPromise<LiveTvSeriesTimerInfoDto> {
            return LiveTvServiceApiFp(configuration).getLivetvTimersDefaults(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Gets tuner hosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTunerhosts(options?: any): AxiosPromise<Array<LiveTvTunerHostInfo>> {
            return LiveTvServiceApiFp(configuration).getLivetvTunerhosts(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTunerhostsTypes(options?: any): AxiosPromise<Array<NameIdPair>> {
            return LiveTvServiceApiFp(configuration).getLivetvTunerhostsTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivetvTunersDiscvover(options?: any): AxiosPromise<Array<LiveTvTunerHostInfo>> {
            return LiveTvServiceApiFp(configuration).getLivetvTunersDiscvover(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headLivetvChannelmappingoptions(providerId: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).headLivetvChannelmappingoptions(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headLivetvChannelmappings(providerId: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).headLivetvChannelmappings(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsLivetvChannelmappingoptions(providerId: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).optionsLivetvChannelmappingoptions(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optionsLivetvChannelmappings(providerId: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).optionsLivetvChannelmappings(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchLivetvChannelmappingoptions(providerId: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).patchLivetvChannelmappingoptions(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchLivetvChannelmappings(providerId: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).patchLivetvChannelmappings(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvChannelmappingoptions(providerId: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).postLivetvChannelmappingoptions(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {LiveTVApiSetChannelMapping} body SetChannelMapping
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvChannelmappings(body: LiveTVApiSetChannelMapping, providerId: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).postLivetvChannelmappings(body, providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Adds a listing provider
         * @param {LiveTvListingsProviderInfo} body ListingsProviderInfo: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvListingproviders(body: LiveTvListingsProviderInfo, options?: any): AxiosPromise<LiveTvListingsProviderInfo> {
            return LiveTvServiceApiFp(configuration).postLivetvListingproviders(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Sets a channel disabled or not
         * @param {LiveTVApiSetChannelDisabled} body SetChannelDisabled
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvManageChannelsByIdDisabled(body: LiveTVApiSetChannelDisabled, id: string, options?: any): AxiosPromise<QueryResultEmbyLiveTVChannelManagementInfo> {
            return LiveTvServiceApiFp(configuration).postLivetvManageChannelsByIdDisabled(body, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Sets a channel sort index
         * @param {LiveTVApiSetChannelSortIndex} body SetChannelSortIndex
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvManageChannelsByIdSortindex(body: LiveTVApiSetChannelSortIndex, id: string, options?: any): AxiosPromise<QueryResultEmbyLiveTVChannelManagementInfo> {
            return LiveTvServiceApiFp(configuration).postLivetvManageChannelsByIdSortindex(body, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets available live tv epgs..
         * @param {LiveTVApiGetPrograms} body GetPrograms
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional filter by user id.
         * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
         * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvPrograms(body: LiveTVApiGetPrograms, channelIds?: string, userId?: string, minStartDate?: string, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, genreIds?: string, options?: any): AxiosPromise<QueryResultBaseItemDto> {
            return LiveTvServiceApiFp(configuration).postLivetvPrograms(body, channelIds, userId, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, genreIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Creates a live tv series timer
         * @param {LiveTvSeriesTimerInfoDto} body SeriesTimerInfoDto: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvSeriestimers(body: LiveTvSeriesTimerInfoDto, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).postLivetvSeriestimers(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Updates a live tv series timer
         * @param {LiveTvSeriesTimerInfoDto} body SeriesTimerInfoDto: 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvSeriestimersById(body: LiveTvSeriesTimerInfoDto, id: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).postLivetvSeriestimersById(body, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Creates a live tv timer
         * @param {LiveTvTimerInfoDto} body TimerInfoDto: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvTimers(body: LiveTvTimerInfoDto, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).postLivetvTimers(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Updates a live tv timer
         * @param {LiveTvTimerInfoDto} body TimerInfoDto: 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvTimersById(body: LiveTvTimerInfoDto, id: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).postLivetvTimersById(body, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Adds a tuner host
         * @param {LiveTvTunerHostInfo} body TunerHostInfo: 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvTunerhosts(body: LiveTvTunerHostInfo, options?: any): AxiosPromise<LiveTvTunerHostInfo> {
            return LiveTvServiceApiFp(configuration).postLivetvTunerhosts(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Resets a tv tuner
         * @param {string} id Tuner Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLivetvTunersByIdReset(id: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).postLivetvTunersByIdReset(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLivetvChannelmappingoptions(providerId: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).putLivetvChannelmappingoptions(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {LiveTVApiSetChannelMapping} body SetChannelMapping
         * @param {string} providerId Provider id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLivetvChannelmappings(body: LiveTVApiSetChannelMapping, providerId: string, options?: any): AxiosPromise<void> {
            return LiveTvServiceApiFp(configuration).putLivetvChannelmappings(body, providerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LiveTvServiceApi - object-oriented interface
 * @export
 * @class LiveTvServiceApi
 * @extends {BaseAPI}
 */
export class LiveTvServiceApi extends BaseAPI {
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public deleteLivetvChannelmappingoptions(providerId: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).deleteLivetvChannelmappingoptions(providerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public deleteLivetvChannelmappings(providerId: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).deleteLivetvChannelmappings(providerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Deletes a listing provider
     * @param {string} [id] Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public deleteLivetvListingproviders(id?: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).deleteLivetvListingproviders(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Deletes a live tv recording
     * @param {string} id Recording Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public deleteLivetvRecordingsById(id: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).deleteLivetvRecordingsById(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Cancels a live tv series timer
     * @param {string} id Timer Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public deleteLivetvSeriestimersById(id: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).deleteLivetvSeriestimersById(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Cancels a live tv timer
     * @param {string} id Timer Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public deleteLivetvTimersById(id: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).deleteLivetvTimersById(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Deletes a tuner host
     * @param {string} [id] Tuner host id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public deleteLivetvTunerhosts(id?: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).deleteLivetvTunerhosts(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvChannelmappingoptions(providerId: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvChannelmappingoptions(providerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvChannelmappings(providerId: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvChannelmappings(providerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets available live tv channels.
     * @param {string} [type] Optional filter by channel type.
     * @param {string} [userId] Optional filter by user and attach user data.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {boolean} [isMovie] Optional filter for movies.
     * @param {boolean} [isSeries] Optional filter for series.
     * @param {boolean} [isNews] Optional filter for news.
     * @param {boolean} [isKids] Optional filter for kids.
     * @param {boolean} [isSports] Optional filter for sports.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {boolean} [isFavorite] Filter by channels that are favorites, or not.
     * @param {boolean} [isLiked] Filter by channels that are liked, or not.
     * @param {boolean} [isDisliked] Filter by channels that are disliked, or not.
     * @param {boolean} [enableFavoriteSorting] Incorporate favorite and like status into channel sorting.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvChannels(type?: string, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableFavoriteSorting?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, addCurrentProgram?: boolean, enableUserData?: boolean, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets a live tv channel
     * @param {string} id Channel Id
     * @param {string} [userId] Optional attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvChannelsById(id: string, userId?: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvChannelsById(id, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @summary Gets live tv channel tags
     * @param {string} [artistType] Artist or AlbumArtist
     * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
     * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
     * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
     * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
     * @param {boolean} [hasTrailer] Optional filter by items with trailers.
     * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
     * @param {number} [minIndexNumber] Optional filter by minimum index number.
     * @param {number} [minPlayers] Optional filter by minimum number of game players.
     * @param {number} [maxPlayers] Optional filter by maximum number of game players.
     * @param {number} [parentIndexNumber] Optional filter by parent index number.
     * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
     * @param {boolean} [isHD] Optional filter by items that are HD or not.
     * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
     * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
     * @param {number} [minCommunityRating] Optional filter by minimum community rating.
     * @param {number} [minCriticRating] Optional filter by minimum critic rating.
     * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
     * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
     * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
     * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
     * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
     * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param {string} [searchTerm] Enter a search term to perform a search request
     * @param {string} [sortOrder] Sort Order - Ascending,Descending
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
     * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
     * @param {boolean} [isMovie] Optional filter for movies.
     * @param {boolean} [isSeries] Optional filter for series.
     * @param {boolean} [isNews] Optional filter for news.
     * @param {boolean} [isKids] Optional filter for kids.
     * @param {boolean} [isSports] Optional filter for sports.
     * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
     * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
     * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
     * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
     * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param {string} [path] Optional filter by Path.
     * @param {string} [userId] User Id
     * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [isLocked] Optional filter by items that are locked.
     * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
     * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
     * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
     * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
     * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
     * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvChanneltags(artistType?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, minIndexNumber?: number, minPlayers?: number, maxPlayers?: number, parentIndexNumber?: number, hasParentalRating?: boolean, isHD?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, airedDuringSeason?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, anyProviderIdEquals?: string, filters?: string, isFavorite?: boolean, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, artists?: string, artistIds?: string, albums?: string, ids?: string, videoTypes?: string, containers?: string, audioCodecs?: string, videoCodecs?: string, subtitleCodecs?: string, path?: string, userId?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, groupItemsIntoCollections?: boolean, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvChanneltags(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @summary Gets live tv channel tag prefixes
     * @param {string} [artistType] Artist or AlbumArtist
     * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
     * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
     * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
     * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
     * @param {boolean} [hasTrailer] Optional filter by items with trailers.
     * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
     * @param {number} [minIndexNumber] Optional filter by minimum index number.
     * @param {number} [minPlayers] Optional filter by minimum number of game players.
     * @param {number} [maxPlayers] Optional filter by maximum number of game players.
     * @param {number} [parentIndexNumber] Optional filter by parent index number.
     * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
     * @param {boolean} [isHD] Optional filter by items that are HD or not.
     * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
     * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
     * @param {number} [minCommunityRating] Optional filter by minimum community rating.
     * @param {number} [minCriticRating] Optional filter by minimum critic rating.
     * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
     * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
     * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
     * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
     * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
     * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param {string} [searchTerm] Enter a search term to perform a search request
     * @param {string} [sortOrder] Sort Order - Ascending,Descending
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
     * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
     * @param {boolean} [isMovie] Optional filter for movies.
     * @param {boolean} [isSeries] Optional filter for series.
     * @param {boolean} [isNews] Optional filter for news.
     * @param {boolean} [isKids] Optional filter for kids.
     * @param {boolean} [isSports] Optional filter for sports.
     * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
     * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
     * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
     * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
     * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param {string} [path] Optional filter by Path.
     * @param {string} [userId] User Id
     * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [isLocked] Optional filter by items that are locked.
     * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
     * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
     * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
     * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
     * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
     * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvChanneltagsPrefixes(artistType?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, minIndexNumber?: number, minPlayers?: number, maxPlayers?: number, parentIndexNumber?: number, hasParentalRating?: boolean, isHD?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, airedDuringSeason?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, anyProviderIdEquals?: string, filters?: string, isFavorite?: boolean, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, artists?: string, artistIds?: string, albums?: string, ids?: string, videoTypes?: string, containers?: string, audioCodecs?: string, videoCodecs?: string, subtitleCodecs?: string, path?: string, userId?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, groupItemsIntoCollections?: boolean, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvChanneltagsPrefixes(artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets the epg.
     * @param {string} [type] Optional filter by channel type.
     * @param {string} [userId] Optional filter by user and attach user data.
     * @param {string} [genreIds] The genres to return guide information for.
     * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {boolean} [isMovie] Optional filter for movies.
     * @param {boolean} [isSeries] Optional filter for series.
     * @param {boolean} [isNews] Optional filter for news.
     * @param {boolean} [isKids] Optional filter for kids.
     * @param {boolean} [isSports] Optional filter for sports.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {boolean} [isFavorite] Filter by channels that are favorites, or not.
     * @param {boolean} [isLiked] Filter by channels that are liked, or not.
     * @param {boolean} [isDisliked] Filter by channels that are disliked, or not.
     * @param {boolean} [enableFavoriteSorting] Incorporate favorite and like status into channel sorting.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {string} [channelIds] The channels to return guide information for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvEPG(type?: string, userId?: string, genreIds?: string, minStartDate?: string, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableFavoriteSorting?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, addCurrentProgram?: boolean, enableUserData?: boolean, channelIds?: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvEPG(type, userId, genreIds, minStartDate, maxStartDate, minEndDate, maxEndDate, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableFavoriteSorting, enableImages, imageTypeLimit, enableImageTypes, fields, addCurrentProgram, enableUserData, channelIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets the top level live tv folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvFolder(options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvFolder(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets guide info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvGuideinfo(options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvGuideinfo(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets available live tv services.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvInfo(options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvInfo(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Gets current listing providers
     * @param {string} channelId Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvListingproviders(channelId: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvListingproviders(channelId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Gets listing provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvListingprovidersAvailable(options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvListingprovidersAvailable(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvListingprovidersDefault(options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvListingprovidersDefault(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Gets available lineups
     * @param {string} [id] Provider id
     * @param {string} [type] Provider Type
     * @param {string} [location] Location
     * @param {string} [country] Country
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvListingprovidersLineups(id?: string, type?: string, location?: string, country?: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvListingprovidersLineups(id, type, location, country, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Gets available lineups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvListingprovidersSchedulesdirectCountries(options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvListingprovidersSchedulesdirectCountries(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @summary Gets a live tv channel
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvLiverecordingsByIdStream(id: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvLiverecordingsByIdStream(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @summary Gets a live tv channel
     * @param {string} id 
     * @param {string} container 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvLivestreamfilesByIdByContainer(id: string, container: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvLivestreamfilesByIdByContainer(id, container, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Gets the channel management list
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
     * @param {string} [sortOrder] Sort Order - Ascending,Descending
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvManageChannels(startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvManageChannels(startIndex, limit, sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets available live tv epgs..
     * @param {string} [channelIds] The channels to return guide information for.
     * @param {string} [userId] Optional filter by user id.
     * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
     * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {boolean} [isMovie] Optional filter for movies.
     * @param {boolean} [isSeries] Optional filter for series.
     * @param {boolean} [isNews] Optional filter for news.
     * @param {boolean} [isKids] Optional filter for kids.
     * @param {boolean} [isSports] Optional filter for sports.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
     * @param {string} [sortOrder] Sort Order - Ascending,Descending
     * @param {string} [genreIds] The genres to return guide information for.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvPrograms(channelIds?: string, userId?: string, hasAired?: boolean, minStartDate?: string, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, genreIds?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, fields?: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvPrograms(channelIds, userId, hasAired, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, fields, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets available live tv epgs..
     * @param {string} [userId] Optional filter by user id.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
     * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
     * @param {boolean} [isSeries] Optional filter for series.
     * @param {boolean} [isMovie] Optional filter for movies.
     * @param {boolean} [isNews] Optional filter for news.
     * @param {boolean} [isKids] Optional filter for kids.
     * @param {boolean} [isSports] Optional filter for sports.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [genreIds] The genres to return guide information for.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvProgramsRecommended(userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, genreIds?: string, fields?: string, enableUserData?: boolean, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvProgramsRecommended(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets live tv recordings
     * @param {string} [channelId] Optional filter by channel id.
     * @param {string} [status] Optional filter by recording status.
     * @param {boolean} [isInProgress] Optional filter by recordings that are in progress, or not.
     * @param {string} [seriesTimerId] Optional filter by recordings belonging to a series timer
     * @param {string} [artistType] Artist or AlbumArtist
     * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
     * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
     * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
     * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
     * @param {boolean} [hasTrailer] Optional filter by items with trailers.
     * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
     * @param {number} [minIndexNumber] Optional filter by minimum index number.
     * @param {number} [minPlayers] Optional filter by minimum number of game players.
     * @param {number} [maxPlayers] Optional filter by maximum number of game players.
     * @param {number} [parentIndexNumber] Optional filter by parent index number.
     * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating
     * @param {boolean} [isHD] Optional filter by items that are HD or not.
     * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
     * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
     * @param {number} [minCommunityRating] Optional filter by minimum community rating.
     * @param {number} [minCriticRating] Optional filter by minimum critic rating.
     * @param {number} [airedDuringSeason] Gets all episodes that aired during a season, including specials.
     * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [minDateLastSaved] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [minDateLastSavedForUser] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
     * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
     * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
     * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
     * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param {string} [searchTerm] Enter a search term to perform a search request
     * @param {string} [sortOrder] Sort Order - Ascending,Descending
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {string} [anyProviderIdEquals] Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form &#x27;prov.id&#x27;, e.g. &#x27;imdb.tt123456&#x27;. This allows multiple, comma delimeted value pairs.
     * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
     * @param {boolean} [isMovie] Optional filter for movies.
     * @param {boolean} [isSeries] Optional filter for series.
     * @param {boolean} [isNews] Optional filter for news.
     * @param {boolean} [isKids] Optional filter for kids.
     * @param {boolean} [isSports] Optional filter for sports.
     * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
     * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
     * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param {string} [artists] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param {string} [artistIds] Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param {string} [ids] Optional. If specific items are needed, specify a list of item id&#x27;s to retrieve. This allows multiple, comma delimited.
     * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param {string} [containers] Optional filter by Container. Allows multiple, comma delimeted.
     * @param {string} [audioCodecs] Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param {string} [videoCodecs] Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param {string} [subtitleCodecs] Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param {string} [path] Optional filter by Path.
     * @param {string} [userId] User Id
     * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [isLocked] Optional filter by items that are locked.
     * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders
     * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings
     * @param {boolean} [groupItemsIntoCollections] Whether or not to hide items behind their boxsets.
     * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
     * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
     * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvRecordings(channelId?: string, status?: string, isInProgress?: boolean, seriesTimerId?: string, artistType?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, minIndexNumber?: number, minPlayers?: number, maxPlayers?: number, parentIndexNumber?: number, hasParentalRating?: boolean, isHD?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, airedDuringSeason?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, anyProviderIdEquals?: string, filters?: string, isFavorite?: boolean, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, artists?: string, artistIds?: string, albums?: string, ids?: string, videoTypes?: string, containers?: string, audioCodecs?: string, videoCodecs?: string, subtitleCodecs?: string, path?: string, userId?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, groupItemsIntoCollections?: boolean, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvRecordings(channelId, status, isInProgress, seriesTimerId, artistType, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, minIndexNumber, minPlayers, maxPlayers, parentIndexNumber, hasParentalRating, isHD, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, airedDuringSeason, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, anyProviderIdEquals, filters, isFavorite, isMovie, isSeries, isNews, isKids, isSports, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableImages, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, artists, artistIds, albums, ids, videoTypes, containers, audioCodecs, videoCodecs, subtitleCodecs, path, userId, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, groupItemsIntoCollections, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets a live tv recording
     * @param {string} id Recording Id
     * @param {string} [userId] Optional attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvRecordingsById(id: string, userId?: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvRecordingsById(id, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets recording folders
     * @param {string} [userId] Optional filter by user and attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvRecordingsFolders(userId?: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvRecordingsFolders(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets live tv recording groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvRecordingsGroups(options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvRecordingsGroups(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets live tv recordings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvRecordingsSeries(options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvRecordingsSeries(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets live tv series timers
     * @param {string} [sortBy] Optional. Sort by SortName or Priority
     * @param {string} [sortOrder] Optional. Sort in Ascending or Descending order
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvSeriestimers(sortBy?: string, sortOrder?: string, startIndex?: number, limit?: number, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvSeriestimers(sortBy, sortOrder, startIndex, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets a live tv series timer
     * @param {string} id Timer Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvSeriestimersById(id: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvSeriestimersById(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets live tv timers
     * @param {string} [channelId] Optional filter by channel id.
     * @param {string} [seriesTimerId] Optional filter by timers belonging to a series timer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvTimers(channelId?: string, seriesTimerId?: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvTimers(channelId, seriesTimerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets a live tv timer
     * @param {string} id Timer Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvTimersById(id: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvTimersById(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets default values for a new timer
     * @param {string} [programId] Optional, to attach default values based on a program.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvTimersDefaults(programId?: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvTimersDefaults(programId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Gets tuner hosts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvTunerhosts(options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvTunerhosts(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvTunerhostsTypes(options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvTunerhostsTypes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public getLivetvTunersDiscvover(options?: any) {
        return LiveTvServiceApiFp(this.configuration).getLivetvTunersDiscvover(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public headLivetvChannelmappingoptions(providerId: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).headLivetvChannelmappingoptions(providerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public headLivetvChannelmappings(providerId: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).headLivetvChannelmappings(providerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public optionsLivetvChannelmappingoptions(providerId: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).optionsLivetvChannelmappingoptions(providerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public optionsLivetvChannelmappings(providerId: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).optionsLivetvChannelmappings(providerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public patchLivetvChannelmappingoptions(providerId: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).patchLivetvChannelmappingoptions(providerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public patchLivetvChannelmappings(providerId: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).patchLivetvChannelmappings(providerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public postLivetvChannelmappingoptions(providerId: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).postLivetvChannelmappingoptions(providerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {LiveTVApiSetChannelMapping} body SetChannelMapping
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public postLivetvChannelmappings(body: LiveTVApiSetChannelMapping, providerId: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).postLivetvChannelmappings(body, providerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Adds a listing provider
     * @param {LiveTvListingsProviderInfo} body ListingsProviderInfo: 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public postLivetvListingproviders(body: LiveTvListingsProviderInfo, options?: any) {
        return LiveTvServiceApiFp(this.configuration).postLivetvListingproviders(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Sets a channel disabled or not
     * @param {LiveTVApiSetChannelDisabled} body SetChannelDisabled
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public postLivetvManageChannelsByIdDisabled(body: LiveTVApiSetChannelDisabled, id: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).postLivetvManageChannelsByIdDisabled(body, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Sets a channel sort index
     * @param {LiveTVApiSetChannelSortIndex} body SetChannelSortIndex
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public postLivetvManageChannelsByIdSortindex(body: LiveTVApiSetChannelSortIndex, id: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).postLivetvManageChannelsByIdSortindex(body, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets available live tv epgs..
     * @param {LiveTVApiGetPrograms} body GetPrograms
     * @param {string} [channelIds] The channels to return guide information for.
     * @param {string} [userId] Optional filter by user id.
     * @param {string} [minStartDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxStartDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {string} [minEndDate] Optional. The minimum premiere date. Format &#x3D; ISO
     * @param {string} [maxEndDate] Optional. The maximum premiere date. Format &#x3D; ISO
     * @param {boolean} [isMovie] Optional filter for movies.
     * @param {boolean} [isSeries] Optional filter for series.
     * @param {boolean} [isNews] Optional filter for news.
     * @param {boolean} [isKids] Optional filter for kids.
     * @param {boolean} [isSports] Optional filter for sports.
     * @param {string} [genreIds] The genres to return guide information for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public postLivetvPrograms(body: LiveTVApiGetPrograms, channelIds?: string, userId?: string, minStartDate?: string, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, genreIds?: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).postLivetvPrograms(body, channelIds, userId, minStartDate, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, genreIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Creates a live tv series timer
     * @param {LiveTvSeriesTimerInfoDto} body SeriesTimerInfoDto: 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public postLivetvSeriestimers(body: LiveTvSeriesTimerInfoDto, options?: any) {
        return LiveTvServiceApiFp(this.configuration).postLivetvSeriestimers(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Updates a live tv series timer
     * @param {LiveTvSeriesTimerInfoDto} body SeriesTimerInfoDto: 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public postLivetvSeriestimersById(body: LiveTvSeriesTimerInfoDto, id: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).postLivetvSeriestimersById(body, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Creates a live tv timer
     * @param {LiveTvTimerInfoDto} body TimerInfoDto: 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public postLivetvTimers(body: LiveTvTimerInfoDto, options?: any) {
        return LiveTvServiceApiFp(this.configuration).postLivetvTimers(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Updates a live tv timer
     * @param {LiveTvTimerInfoDto} body TimerInfoDto: 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public postLivetvTimersById(body: LiveTvTimerInfoDto, id: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).postLivetvTimersById(body, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Adds a tuner host
     * @param {LiveTvTunerHostInfo} body TunerHostInfo: 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public postLivetvTunerhosts(body: LiveTvTunerHostInfo, options?: any) {
        return LiveTvServiceApiFp(this.configuration).postLivetvTunerhosts(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Resets a tv tuner
     * @param {string} id Tuner Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public postLivetvTunersByIdReset(id: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).postLivetvTunersByIdReset(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public putLivetvChannelmappingoptions(providerId: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).putLivetvChannelmappingoptions(providerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {LiveTVApiSetChannelMapping} body SetChannelMapping
     * @param {string} providerId Provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvServiceApi
     */
    public putLivetvChannelmappings(body: LiveTVApiSetChannelMapping, providerId: string, options?: any) {
        return LiveTvServiceApiFp(this.configuration).putLivetvChannelmappings(body, providerId, options).then((request) => request(this.axios, this.basePath));
    }
}
