/* tslint:disable */
/* eslint-disable */
/**
 * Emby Server API
 * Explore the Emby Server API
 *
 * OpenAPI spec version: 4.1.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { ImageInfo } from '../models';
/**
 * ImageServiceApi - axios parameter creator
 * @export
 */
export const ImageServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsByIdImagesByType: async (id: string, type: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteItemsByIdImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling deleteItemsByIdImagesByType.');
            }
            const localVarPath = `/Items/{Id}/Images/{Type}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsByIdImagesByTypeByIndex: async (id: string, type: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteItemsByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling deleteItemsByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling deleteItemsByIdImagesByTypeByIndex.');
            }
            const localVarPath = `/Items/{Id}/Images/{Type}/{Index}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersByIdImagesByType: async (id: string, type: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteUsersByIdImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling deleteUsersByIdImagesByType.');
            }
            const localVarPath = `/Users/{Id}/Images/{Type}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersByIdImagesByTypeByIndex: async (id: string, type: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteUsersByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling deleteUsersByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling deleteUsersByIdImagesByTypeByIndex.');
            }
            const localVarPath = `/Users/{Id}/Images/{Type}/{Index}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistsByNameImagesByType: async (name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getArtistsByNameImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getArtistsByNameImagesByType.');
            }
            const localVarPath = `/Artists/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistsByNameImagesByTypeByIndex: async (name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getArtistsByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getArtistsByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getArtistsByNameImagesByTypeByIndex.');
            }
            const localVarPath = `/Artists/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGamegenresByNameImagesByType: async (name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getGamegenresByNameImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getGamegenresByNameImagesByType.');
            }
            const localVarPath = `/GameGenres/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGamegenresByNameImagesByTypeByIndex: async (name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getGamegenresByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getGamegenresByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getGamegenresByNameImagesByTypeByIndex.');
            }
            const localVarPath = `/GameGenres/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenresByNameImagesByType: async (name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getGenresByNameImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getGenresByNameImagesByType.');
            }
            const localVarPath = `/Genres/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenresByNameImagesByTypeByIndex: async (name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getGenresByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getGenresByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getGenresByNameImagesByTypeByIndex.');
            }
            const localVarPath = `/Genres/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets information about an item's images
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdImages: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getItemsByIdImages.');
            }
            const localVarPath = `/Items/{Id}/Images`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdImagesByType: async (id: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getItemsByIdImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getItemsByIdImagesByType.');
            }
            const localVarPath = `/Items/{Id}/Images/{Type}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdImagesByTypeByIndex: async (id: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getItemsByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getItemsByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getItemsByIdImagesByTypeByIndex.');
            }
            const localVarPath = `/Items/{Id}/Images/{Type}/{Index}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output foramt of the image - original,gif,jpg,png
         * @param {number} percentPlayed Optional percent to render for the percent played overlay
         * @param {number} unplayedCount Optional unplayed count overlay to render
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount: async (id: string, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, type: string, index: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, enableImageEnhancers?: boolean, addPlayedIndicator?: boolean, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            const localVarPath = `/Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnplayedCount}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"MaxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"MaxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"Tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"Format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"PercentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"UnplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicgenresByNameImagesByType: async (name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getMusicgenresByNameImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getMusicgenresByNameImagesByType.');
            }
            const localVarPath = `/MusicGenres/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicgenresByNameImagesByTypeByIndex: async (name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getMusicgenresByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getMusicgenresByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getMusicgenresByNameImagesByTypeByIndex.');
            }
            const localVarPath = `/MusicGenres/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonsByNameImagesByType: async (name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPersonsByNameImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getPersonsByNameImagesByType.');
            }
            const localVarPath = `/Persons/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonsByNameImagesByTypeByIndex: async (name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPersonsByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getPersonsByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getPersonsByNameImagesByTypeByIndex.');
            }
            const localVarPath = `/Persons/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiosByNameImagesByType: async (name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getStudiosByNameImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getStudiosByNameImagesByType.');
            }
            const localVarPath = `/Studios/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiosByNameImagesByTypeByIndex: async (name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getStudiosByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getStudiosByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getStudiosByNameImagesByTypeByIndex.');
            }
            const localVarPath = `/Studios/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByIdImagesByType: async (id: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUsersByIdImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getUsersByIdImagesByType.');
            }
            const localVarPath = `/Users/{Id}/Images/{Type}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByIdImagesByTypeByIndex: async (id: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUsersByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getUsersByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getUsersByIdImagesByTypeByIndex.');
            }
            const localVarPath = `/Users/{Id}/Images/{Type}/{Index}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headArtistsByNameImagesByType: async (name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headArtistsByNameImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling headArtistsByNameImagesByType.');
            }
            const localVarPath = `/Artists/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headArtistsByNameImagesByTypeByIndex: async (name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headArtistsByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling headArtistsByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling headArtistsByNameImagesByTypeByIndex.');
            }
            const localVarPath = `/Artists/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGamegenresByNameImagesByType: async (name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headGamegenresByNameImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling headGamegenresByNameImagesByType.');
            }
            const localVarPath = `/GameGenres/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGamegenresByNameImagesByTypeByIndex: async (name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headGamegenresByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling headGamegenresByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling headGamegenresByNameImagesByTypeByIndex.');
            }
            const localVarPath = `/GameGenres/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGenresByNameImagesByType: async (name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headGenresByNameImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling headGenresByNameImagesByType.');
            }
            const localVarPath = `/Genres/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGenresByNameImagesByTypeByIndex: async (name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headGenresByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling headGenresByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling headGenresByNameImagesByTypeByIndex.');
            }
            const localVarPath = `/Genres/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemsByIdImagesByType: async (id: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling headItemsByIdImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling headItemsByIdImagesByType.');
            }
            const localVarPath = `/Items/{Id}/Images/{Type}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemsByIdImagesByTypeByIndex: async (id: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling headItemsByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling headItemsByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling headItemsByIdImagesByTypeByIndex.');
            }
            const localVarPath = `/Items/{Id}/Images/{Type}/{Index}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output foramt of the image - original,gif,jpg,png
         * @param {number} percentPlayed Optional percent to render for the percent played overlay
         * @param {number} unplayedCount Optional unplayed count overlay to render
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount: async (id: string, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, type: string, index: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, enableImageEnhancers?: boolean, addPlayedIndicator?: boolean, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount.');
            }
            const localVarPath = `/Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnplayedCount}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"MaxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"MaxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"Tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"Format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"PercentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"UnplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMusicgenresByNameImagesByType: async (name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headMusicgenresByNameImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling headMusicgenresByNameImagesByType.');
            }
            const localVarPath = `/MusicGenres/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMusicgenresByNameImagesByTypeByIndex: async (name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headMusicgenresByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling headMusicgenresByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling headMusicgenresByNameImagesByTypeByIndex.');
            }
            const localVarPath = `/MusicGenres/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headPersonsByNameImagesByType: async (name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headPersonsByNameImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling headPersonsByNameImagesByType.');
            }
            const localVarPath = `/Persons/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headPersonsByNameImagesByTypeByIndex: async (name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headPersonsByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling headPersonsByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling headPersonsByNameImagesByTypeByIndex.');
            }
            const localVarPath = `/Persons/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headStudiosByNameImagesByType: async (name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headStudiosByNameImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling headStudiosByNameImagesByType.');
            }
            const localVarPath = `/Studios/{Name}/Images/{Type}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headStudiosByNameImagesByTypeByIndex: async (name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headStudiosByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling headStudiosByNameImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling headStudiosByNameImagesByTypeByIndex.');
            }
            const localVarPath = `/Studios/{Name}/Images/{Type}/{Index}`
                .replace(`{${"Name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUsersByIdImagesByType: async (id: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling headUsersByIdImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling headUsersByIdImagesByType.');
            }
            const localVarPath = `/Users/{Id}/Images/{Type}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUsersByIdImagesByTypeByIndex: async (id: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling headUsersByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling headUsersByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling headUsersByIdImagesByTypeByIndex.');
            }
            const localVarPath = `/Users/{Id}/Images/{Type}/{Index}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxWidth !== undefined) {
                localVarQueryParameter['MaxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['MaxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['Width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['Height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['Quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['Tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['CropWhitespace'] = cropWhitespace;
            }

            if (enableImageEnhancers !== undefined) {
                localVarQueryParameter['EnableImageEnhancers'] = enableImageEnhancers;
            }

            if (format !== undefined) {
                localVarQueryParameter['Format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['AddPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['PercentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['UnplayedCount'] = unplayedCount;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['BackgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['ForegroundLayer'] = foregroundLayer;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {Object} body Binary stream
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItemsByIdImagesByType: async (body: Object, id: string, type: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postItemsByIdImagesByType.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postItemsByIdImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling postItemsByIdImagesByType.');
            }
            const localVarPath = `/Items/{Id}/Images/{Type}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {Object} body Binary stream
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItemsByIdImagesByTypeByIndex: async (body: Object, id: string, type: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postItemsByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postItemsByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling postItemsByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling postItemsByIdImagesByTypeByIndex.');
            }
            const localVarPath = `/Items/{Id}/Images/{Type}/{Index}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Updates the index for an item image
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} newIndex The new image index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItemsByIdImagesByTypeByIndexIndex: async (id: string, type: string, index: number, newIndex: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postItemsByIdImagesByTypeByIndexIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling postItemsByIdImagesByTypeByIndexIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling postItemsByIdImagesByTypeByIndexIndex.');
            }
            // verify required parameter 'newIndex' is not null or undefined
            if (newIndex === null || newIndex === undefined) {
                throw new RequiredError('newIndex','Required parameter newIndex was null or undefined when calling postItemsByIdImagesByTypeByIndexIndex.');
            }
            const localVarPath = `/Items/{Id}/Images/{Type}/{Index}/Index`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (newIndex !== undefined) {
                localVarQueryParameter['NewIndex'] = newIndex;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @param {Object} body Binary stream
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByIdImagesByType: async (body: Object, id: string, type: string, index?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postUsersByIdImagesByType.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postUsersByIdImagesByType.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling postUsersByIdImagesByType.');
            }
            const localVarPath = `/Users/{Id}/Images/{Type}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (index !== undefined) {
                localVarQueryParameter['Index'] = index;
            }

            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @param {Object} body Binary stream
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByIdImagesByTypeByIndex: async (body: Object, id: string, type: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postUsersByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postUsersByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling postUsersByIdImagesByTypeByIndex.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling postUsersByIdImagesByTypeByIndex.');
            }
            const localVarPath = `/Users/{Id}/Images/{Type}/{Index}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"Index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageServiceApi - functional programming interface
 * @export
 */
export const ImageServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemsByIdImagesByType(id: string, type: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).deleteItemsByIdImagesByType(id, type, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemsByIdImagesByTypeByIndex(id: string, type: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).deleteItemsByIdImagesByTypeByIndex(id, type, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsersByIdImagesByType(id: string, type: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).deleteUsersByIdImagesByType(id, type, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsersByIdImagesByTypeByIndex(id: string, type: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).deleteUsersByIdImagesByTypeByIndex(id, type, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtistsByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtistsByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGamegenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGamegenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets information about an item's images
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByIdImages(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageInfo>>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getItemsByIdImages(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByIdImagesByType(id: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByIdImagesByTypeByIndex(id: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output foramt of the image - original,gif,jpg,png
         * @param {number} percentPlayed Optional percent to render for the percent played overlay
         * @param {number} unplayedCount Optional unplayed count overlay to render
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id: string, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, type: string, index: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, enableImageEnhancers?: boolean, addPlayedIndicator?: boolean, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicgenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicgenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonsByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonsByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudiosByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudiosByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersByIdImagesByType(id: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersByIdImagesByTypeByIndex(id: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).getUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headArtistsByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).headArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headArtistsByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).headArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headGamegenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).headGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headGamegenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).headGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headGenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).headGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headGenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).headGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headItemsByIdImagesByType(id: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).headItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headItemsByIdImagesByTypeByIndex(id: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).headItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output foramt of the image - original,gif,jpg,png
         * @param {number} percentPlayed Optional percent to render for the percent played overlay
         * @param {number} unplayedCount Optional unplayed count overlay to render
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id: string, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, type: string, index: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, enableImageEnhancers?: boolean, addPlayedIndicator?: boolean, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headMusicgenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).headMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headMusicgenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).headMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headPersonsByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).headPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headPersonsByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).headPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headStudiosByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).headStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headStudiosByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).headStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headUsersByIdImagesByType(id: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).headUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headUsersByIdImagesByTypeByIndex(id: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).headUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {Object} body Binary stream
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postItemsByIdImagesByType(body: Object, id: string, type: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).postItemsByIdImagesByType(body, id, type, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {Object} body Binary stream
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postItemsByIdImagesByTypeByIndex(body: Object, id: string, type: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).postItemsByIdImagesByTypeByIndex(body, id, type, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Updates the index for an item image
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} newIndex The new image index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postItemsByIdImagesByTypeByIndexIndex(id: string, type: string, index: number, newIndex: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).postItemsByIdImagesByTypeByIndexIndex(id, type, index, newIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @param {Object} body Binary stream
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersByIdImagesByType(body: Object, id: string, type: string, index?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).postUsersByIdImagesByType(body, id, type, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @param {Object} body Binary stream
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersByIdImagesByTypeByIndex(body: Object, id: string, type: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageServiceApiAxiosParamCreator(configuration).postUsersByIdImagesByTypeByIndex(body, id, type, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageServiceApi - factory interface
 * @export
 */
export const ImageServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsByIdImagesByType(id: string, type: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).deleteItemsByIdImagesByType(id, type, index, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsByIdImagesByTypeByIndex(id: string, type: string, index: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).deleteItemsByIdImagesByTypeByIndex(id, type, index, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersByIdImagesByType(id: string, type: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).deleteUsersByIdImagesByType(id, type, index, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersByIdImagesByTypeByIndex(id: string, type: string, index: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).deleteUsersByIdImagesByTypeByIndex(id, type, index, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistsByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).getArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistsByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).getArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGamegenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).getGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGamegenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).getGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).getGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).getGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets information about an item's images
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdImages(id: string, options?: any): AxiosPromise<Array<ImageInfo>> {
            return ImageServiceApiFp(configuration).getItemsByIdImages(id, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdImagesByType(id: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).getItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdImagesByTypeByIndex(id: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).getItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output foramt of the image - original,gif,jpg,png
         * @param {number} percentPlayed Optional percent to render for the percent played overlay
         * @param {number} unplayedCount Optional unplayed count overlay to render
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id: string, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, type: string, index: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, enableImageEnhancers?: boolean, addPlayedIndicator?: boolean, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicgenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).getMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicgenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).getMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonsByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).getPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonsByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).getPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiosByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).getStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiosByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).getStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByIdImagesByType(id: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).getUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByIdImagesByTypeByIndex(id: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).getUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headArtistsByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).headArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headArtistsByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).headArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGamegenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).headGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGamegenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).headGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).headGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).headGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemsByIdImagesByType(id: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).headItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemsByIdImagesByTypeByIndex(id: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).headItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id Item Id
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output foramt of the image - original,gif,jpg,png
         * @param {number} percentPlayed Optional percent to render for the percent played overlay
         * @param {number} unplayedCount Optional unplayed count overlay to render
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id: string, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, type: string, index: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, enableImageEnhancers?: boolean, addPlayedIndicator?: boolean, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMusicgenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).headMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMusicgenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).headMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headPersonsByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).headPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headPersonsByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).headPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headStudiosByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).headStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} name Item name
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headStudiosByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).headStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUsersByIdImagesByType(id: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).headUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(axios, basePath));
        },
        /**
         * No authentication required
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
         * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
         * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
         * @param {number} [unplayedCount] Optional unplayed count overlay to render
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUsersByIdImagesByTypeByIndex(id: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).headUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {Object} body Binary stream
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItemsByIdImagesByType(body: Object, id: string, type: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).postItemsByIdImagesByType(body, id, type, index, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {Object} body Binary stream
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItemsByIdImagesByTypeByIndex(body: Object, id: string, type: string, index: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).postItemsByIdImagesByTypeByIndex(body, id, type, index, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Updates the index for an item image
         * @param {string} id Item Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {number} newIndex The new image index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItemsByIdImagesByTypeByIndexIndex(id: string, type: string, index: number, newIndex: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).postItemsByIdImagesByTypeByIndexIndex(id, type, index, newIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @param {Object} body Binary stream
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} [index] Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByIdImagesByType(body: Object, id: string, type: string, index?: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).postUsersByIdImagesByType(body, id, type, index, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @param {Object} body Binary stream
         * @param {string} id User Id
         * @param {string} type Image Type
         * @param {number} index Image Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersByIdImagesByTypeByIndex(body: Object, id: string, type: string, index: number, options?: any): AxiosPromise<void> {
            return ImageServiceApiFp(configuration).postUsersByIdImagesByTypeByIndex(body, id, type, index, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageServiceApi - object-oriented interface
 * @export
 * @class ImageServiceApi
 * @extends {BaseAPI}
 */
export class ImageServiceApi extends BaseAPI {
    /**
     * Requires authentication as administrator
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public deleteItemsByIdImagesByType(id: string, type: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).deleteItemsByIdImagesByType(id, type, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public deleteItemsByIdImagesByTypeByIndex(id: string, type: string, index: number, options?: any) {
        return ImageServiceApiFp(this.configuration).deleteItemsByIdImagesByTypeByIndex(id, type, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @param {string} id User Id
     * @param {string} type Image Type
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public deleteUsersByIdImagesByType(id: string, type: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).deleteUsersByIdImagesByType(id, type, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @param {string} id User Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public deleteUsersByIdImagesByTypeByIndex(id: string, type: string, index: number, options?: any) {
        return ImageServiceApiFp(this.configuration).deleteUsersByIdImagesByTypeByIndex(id, type, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getArtistsByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).getArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getArtistsByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).getArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getGamegenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).getGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getGamegenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).getGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getGenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).getGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getGenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).getGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets information about an item's images
     * @param {string} id Item Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getItemsByIdImages(id: string, options?: any) {
        return ImageServiceApiFp(this.configuration).getItemsByIdImages(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getItemsByIdImagesByType(id: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).getItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getItemsByIdImagesByTypeByIndex(id: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).getItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id Item Id
     * @param {number} maxWidth The maximum image width to return.
     * @param {number} maxHeight The maximum image height to return.
     * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} format Determines the output foramt of the image - original,gif,jpg,png
     * @param {number} percentPlayed Optional percent to render for the percent played overlay
     * @param {number} unplayedCount Optional unplayed count overlay to render
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id: string, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, type: string, index: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, enableImageEnhancers?: boolean, addPlayedIndicator?: boolean, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getMusicgenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).getMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getMusicgenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).getMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getPersonsByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).getPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getPersonsByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).getPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getStudiosByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).getStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getStudiosByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).getStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id User Id
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getUsersByIdImagesByType(id: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).getUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id User Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getUsersByIdImagesByTypeByIndex(id: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).getUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public headArtistsByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).headArtistsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public headArtistsByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).headArtistsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public headGamegenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).headGamegenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public headGamegenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).headGamegenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public headGenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).headGenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public headGenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).headGenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public headItemsByIdImagesByType(id: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).headItemsByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public headItemsByIdImagesByTypeByIndex(id: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).headItemsByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id Item Id
     * @param {number} maxWidth The maximum image width to return.
     * @param {number} maxHeight The maximum image height to return.
     * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} format Determines the output foramt of the image - original,gif,jpg,png
     * @param {number} percentPlayed Optional percent to render for the percent played overlay
     * @param {number} unplayedCount Optional unplayed count overlay to render
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id: string, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, type: string, index: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, enableImageEnhancers?: boolean, addPlayedIndicator?: boolean, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(id, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, type, index, width, height, quality, cropWhitespace, enableImageEnhancers, addPlayedIndicator, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public headMusicgenresByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).headMusicgenresByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public headMusicgenresByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).headMusicgenresByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public headPersonsByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).headPersonsByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public headPersonsByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).headPersonsByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public headStudiosByNameImagesByType(name: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).headStudiosByNameImagesByType(name, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} name Item name
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public headStudiosByNameImagesByTypeByIndex(name: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).headStudiosByNameImagesByTypeByIndex(name, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id User Id
     * @param {string} type Image Type
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public headUsersByIdImagesByType(id: string, type: string, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).headUsersByIdImagesByType(id, type, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * No authentication required
     * @param {string} id User Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [enableImageEnhancers] Enable or disable image enhancers such as cover art.
     * @param {string} [format] Determines the output foramt of the image - original,gif,jpg,png
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator
     * @param {number} [percentPlayed] Optional percent to render for the percent played overlay
     * @param {number} [unplayedCount] Optional unplayed count overlay to render
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public headUsersByIdImagesByTypeByIndex(id: string, type: string, index: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, enableImageEnhancers?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageServiceApiFp(this.configuration).headUsersByIdImagesByTypeByIndex(id, type, index, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, enableImageEnhancers, format, addPlayedIndicator, percentPlayed, unplayedCount, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {Object} body Binary stream
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public postItemsByIdImagesByType(body: Object, id: string, type: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).postItemsByIdImagesByType(body, id, type, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {Object} body Binary stream
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public postItemsByIdImagesByTypeByIndex(body: Object, id: string, type: string, index: number, options?: any) {
        return ImageServiceApiFp(this.configuration).postItemsByIdImagesByTypeByIndex(body, id, type, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Updates the index for an item image
     * @param {string} id Item Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {number} newIndex The new image index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public postItemsByIdImagesByTypeByIndexIndex(id: string, type: string, index: number, newIndex: number, options?: any) {
        return ImageServiceApiFp(this.configuration).postItemsByIdImagesByTypeByIndexIndex(id, type, index, newIndex, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @param {Object} body Binary stream
     * @param {string} id User Id
     * @param {string} type Image Type
     * @param {number} [index] Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public postUsersByIdImagesByType(body: Object, id: string, type: string, index?: number, options?: any) {
        return ImageServiceApiFp(this.configuration).postUsersByIdImagesByType(body, id, type, index, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @param {Object} body Binary stream
     * @param {string} id User Id
     * @param {string} type Image Type
     * @param {number} index Image Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public postUsersByIdImagesByTypeByIndex(body: Object, id: string, type: string, index: number, options?: any) {
        return ImageServiceApiFp(this.configuration).postUsersByIdImagesByTypeByIndex(body, id, type, index, options).then((request) => request(this.axios, this.basePath));
    }
}
