/* tslint:disable */
/* eslint-disable */
/**
 * Emby Server API
 * Explore the Emby Server API
 *
 * OpenAPI spec version: 4.1.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { ClientCapabilities } from '../models';
import { GeneralCommand } from '../models';
import { NameIdPair } from '../models';
import { PlayRequest } from '../models';
import { PlaystateRequest } from '../models';
import { SessionSessionInfo } from '../models';
/**
 * SessionsServiceApi - axios parameter creator
 * @export
 */
export const SessionsServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} key Auth Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthKeysByKey: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling deleteAuthKeysByKey.');
            }
            const localVarPath = `/Auth/Keys/{Key}`
                .replace(`{${"Key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Removes an additional user from a session
         * @param {string} id Session Id
         * @param {string} userId UserId Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionsByIdUsersByUserid: async (id: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteSessionsByIdUsersByUserid.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteSessionsByIdUsersByUserid.');
            }
            const localVarPath = `/Sessions/{Id}/Users/{UserId}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"UserId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthKeys: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Auth/Keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthProviders: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Auth/Providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a list of sessions
         * @param {string} [controllableByUserId] Optional. Filter by sessions that a given user is allowed to remote control.
         * @param {string} [deviceId] Optional. Filter by device id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (controllableByUserId?: string, deviceId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (controllableByUserId !== undefined) {
                localVarQueryParameter['ControllableByUserId'] = controllableByUserId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['DeviceId'] = deviceId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} app App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthKeys: async (app: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'app' is not null or undefined
            if (app === null || app === undefined) {
                throw new RequiredError('app','Required parameter app was null or undefined when calling postAuthKeys.');
            }
            const localVarPath = `/Auth/Keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (app !== undefined) {
                localVarQueryParameter['App'] = app;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {GeneralCommand} body GeneralCommand: 
         * @param {string} id Session Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdCommand: async (body: GeneralCommand, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSessionsByIdCommand.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postSessionsByIdCommand.');
            }
            const localVarPath = `/Sessions/{Id}/Command`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {string} id Session Id
         * @param {string} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdCommandByCommand: async (id: string, command: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postSessionsByIdCommandByCommand.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command','Required parameter command was null or undefined when calling postSessionsByIdCommandByCommand.');
            }
            const localVarPath = `/Sessions/{Id}/Command/{Command}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a command to a client to display a message to the user
         * @param {string} id Session Id
         * @param {string} text The message text.
         * @param {string} header The message header.
         * @param {number} [timeoutMs] The message timeout. If omitted the user will have to confirm viewing the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdMessage: async (id: string, text: string, header: string, timeoutMs?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postSessionsByIdMessage.');
            }
            // verify required parameter 'text' is not null or undefined
            if (text === null || text === undefined) {
                throw new RequiredError('text','Required parameter text was null or undefined when calling postSessionsByIdMessage.');
            }
            // verify required parameter 'header' is not null or undefined
            if (header === null || header === undefined) {
                throw new RequiredError('header','Required parameter header was null or undefined when calling postSessionsByIdMessage.');
            }
            const localVarPath = `/Sessions/{Id}/Message`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (text !== undefined) {
                localVarQueryParameter['Text'] = text;
            }

            if (header !== undefined) {
                localVarQueryParameter['Header'] = header;
            }

            if (timeoutMs !== undefined) {
                localVarQueryParameter['TimeoutMs'] = timeoutMs;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Instructs a session to play an item
         * @param {PlayRequest} body PlayRequest: 
         * @param {Array&lt;number&gt;} itemIds The ids of the items to play, comma delimited
         * @param {string} playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
         * @param {string} id Session Id
         * @param {number} [startPositionTicks] The starting position of the first item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdPlaying: async (body: PlayRequest, itemIds: Array<number>, playCommand: string, id: string, startPositionTicks?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSessionsByIdPlaying.');
            }
            // verify required parameter 'itemIds' is not null or undefined
            if (itemIds === null || itemIds === undefined) {
                throw new RequiredError('itemIds','Required parameter itemIds was null or undefined when calling postSessionsByIdPlaying.');
            }
            // verify required parameter 'playCommand' is not null or undefined
            if (playCommand === null || playCommand === undefined) {
                throw new RequiredError('playCommand','Required parameter playCommand was null or undefined when calling postSessionsByIdPlaying.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postSessionsByIdPlaying.');
            }
            const localVarPath = `/Sessions/{Id}/Playing`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (itemIds) {
                localVarQueryParameter['ItemIds'] = itemIds;
            }

            if (startPositionTicks !== undefined) {
                localVarQueryParameter['StartPositionTicks'] = startPositionTicks;
            }

            if (playCommand !== undefined) {
                localVarQueryParameter['PlayCommand'] = playCommand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a playstate command to a client
         * @param {PlaystateRequest} body PlaystateRequest: 
         * @param {string} id Session Id
         * @param {string} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdPlayingByCommand: async (body: PlaystateRequest, id: string, command: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSessionsByIdPlayingByCommand.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postSessionsByIdPlayingByCommand.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command','Required parameter command was null or undefined when calling postSessionsByIdPlayingByCommand.');
            }
            const localVarPath = `/Sessions/{Id}/Playing/{Command}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {string} id Session Id
         * @param {string} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdSystemByCommand: async (id: string, command: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postSessionsByIdSystemByCommand.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command','Required parameter command was null or undefined when calling postSessionsByIdSystemByCommand.');
            }
            const localVarPath = `/Sessions/{Id}/System/{Command}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"Command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Adds an additional user to a session
         * @param {string} id Session Id
         * @param {string} userId UserId Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdUsersByUserid: async (id: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postSessionsByIdUsersByUserid.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling postSessionsByIdUsersByUserid.');
            }
            const localVarPath = `/Sessions/{Id}/Users/{UserId}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"UserId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Instructs a session to browse to an item or view
         * @param {string} id Session Id
         * @param {string} itemType The type of item to browse to.
         * @param {string} itemId The Id of the item.
         * @param {string} itemName The name of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdViewing: async (id: string, itemType: string, itemId: string, itemName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postSessionsByIdViewing.');
            }
            // verify required parameter 'itemType' is not null or undefined
            if (itemType === null || itemType === undefined) {
                throw new RequiredError('itemType','Required parameter itemType was null or undefined when calling postSessionsByIdViewing.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling postSessionsByIdViewing.');
            }
            // verify required parameter 'itemName' is not null or undefined
            if (itemName === null || itemName === undefined) {
                throw new RequiredError('itemName','Required parameter itemName was null or undefined when calling postSessionsByIdViewing.');
            }
            const localVarPath = `/Sessions/{Id}/Viewing`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (itemType !== undefined) {
                localVarQueryParameter['ItemType'] = itemType;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['ItemId'] = itemId;
            }

            if (itemName !== undefined) {
                localVarQueryParameter['ItemName'] = itemName;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates capabilities for a device
         * @param {string} id Session Id
         * @param {string} [playableMediaTypes] A list of playable media types, comma delimited. Audio, Video, Book, Game, Photo.
         * @param {string} [supportedCommands] A list of supported remote control commands, comma delimited
         * @param {boolean} [supportsMediaControl] Determines whether media can be played remotely.
         * @param {boolean} [supportsSync] Determines whether sync is supported.
         * @param {boolean} [supportsPersistentIdentifier] Determines whether the device supports a unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsCapabilities: async (id: string, playableMediaTypes?: string, supportedCommands?: string, supportsMediaControl?: boolean, supportsSync?: boolean, supportsPersistentIdentifier?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postSessionsCapabilities.');
            }
            const localVarPath = `/Sessions/Capabilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (id !== undefined) {
                localVarQueryParameter['Id'] = id;
            }

            if (playableMediaTypes !== undefined) {
                localVarQueryParameter['PlayableMediaTypes'] = playableMediaTypes;
            }

            if (supportedCommands !== undefined) {
                localVarQueryParameter['SupportedCommands'] = supportedCommands;
            }

            if (supportsMediaControl !== undefined) {
                localVarQueryParameter['SupportsMediaControl'] = supportsMediaControl;
            }

            if (supportsSync !== undefined) {
                localVarQueryParameter['SupportsSync'] = supportsSync;
            }

            if (supportsPersistentIdentifier !== undefined) {
                localVarQueryParameter['SupportsPersistentIdentifier'] = supportsPersistentIdentifier;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates capabilities for a device
         * @param {ClientCapabilities} body ClientCapabilities: 
         * @param {string} id Session Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsCapabilitiesFull: async (body: ClientCapabilities, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSessionsCapabilitiesFull.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postSessionsCapabilitiesFull.');
            }
            const localVarPath = `/Sessions/Capabilities/Full`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (id !== undefined) {
                localVarQueryParameter['Id'] = id;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports that a session has ended
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsLogout: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsServiceApi - functional programming interface
 * @export
 */
export const SessionsServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} key Auth Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuthKeysByKey(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionsServiceApiAxiosParamCreator(configuration).deleteAuthKeysByKey(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Removes an additional user from a session
         * @param {string} id Session Id
         * @param {string} userId UserId Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSessionsByIdUsersByUserid(id: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionsServiceApiAxiosParamCreator(configuration).deleteSessionsByIdUsersByUserid(id, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthKeys(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionsServiceApiAxiosParamCreator(configuration).getAuthKeys(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthProviders(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await SessionsServiceApiAxiosParamCreator(configuration).getAuthProviders(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets a list of sessions
         * @param {string} [controllableByUserId] Optional. Filter by sessions that a given user is allowed to remote control.
         * @param {string} [deviceId] Optional. Filter by device id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(controllableByUserId?: string, deviceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SessionSessionInfo>>> {
            const localVarAxiosArgs = await SessionsServiceApiAxiosParamCreator(configuration).getSessions(controllableByUserId, deviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @param {string} app App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthKeys(app: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionsServiceApiAxiosParamCreator(configuration).postAuthKeys(app, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {GeneralCommand} body GeneralCommand: 
         * @param {string} id Session Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsByIdCommand(body: GeneralCommand, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionsServiceApiAxiosParamCreator(configuration).postSessionsByIdCommand(body, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {string} id Session Id
         * @param {string} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsByIdCommandByCommand(id: string, command: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionsServiceApiAxiosParamCreator(configuration).postSessionsByIdCommandByCommand(id, command, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a command to a client to display a message to the user
         * @param {string} id Session Id
         * @param {string} text The message text.
         * @param {string} header The message header.
         * @param {number} [timeoutMs] The message timeout. If omitted the user will have to confirm viewing the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsByIdMessage(id: string, text: string, header: string, timeoutMs?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionsServiceApiAxiosParamCreator(configuration).postSessionsByIdMessage(id, text, header, timeoutMs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Instructs a session to play an item
         * @param {PlayRequest} body PlayRequest: 
         * @param {Array&lt;number&gt;} itemIds The ids of the items to play, comma delimited
         * @param {string} playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
         * @param {string} id Session Id
         * @param {number} [startPositionTicks] The starting position of the first item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsByIdPlaying(body: PlayRequest, itemIds: Array<number>, playCommand: string, id: string, startPositionTicks?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionsServiceApiAxiosParamCreator(configuration).postSessionsByIdPlaying(body, itemIds, playCommand, id, startPositionTicks, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a playstate command to a client
         * @param {PlaystateRequest} body PlaystateRequest: 
         * @param {string} id Session Id
         * @param {string} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsByIdPlayingByCommand(body: PlaystateRequest, id: string, command: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionsServiceApiAxiosParamCreator(configuration).postSessionsByIdPlayingByCommand(body, id, command, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {string} id Session Id
         * @param {string} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsByIdSystemByCommand(id: string, command: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionsServiceApiAxiosParamCreator(configuration).postSessionsByIdSystemByCommand(id, command, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Adds an additional user to a session
         * @param {string} id Session Id
         * @param {string} userId UserId Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsByIdUsersByUserid(id: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionsServiceApiAxiosParamCreator(configuration).postSessionsByIdUsersByUserid(id, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Instructs a session to browse to an item or view
         * @param {string} id Session Id
         * @param {string} itemType The type of item to browse to.
         * @param {string} itemId The Id of the item.
         * @param {string} itemName The name of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsByIdViewing(id: string, itemType: string, itemId: string, itemName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionsServiceApiAxiosParamCreator(configuration).postSessionsByIdViewing(id, itemType, itemId, itemName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates capabilities for a device
         * @param {string} id Session Id
         * @param {string} [playableMediaTypes] A list of playable media types, comma delimited. Audio, Video, Book, Game, Photo.
         * @param {string} [supportedCommands] A list of supported remote control commands, comma delimited
         * @param {boolean} [supportsMediaControl] Determines whether media can be played remotely.
         * @param {boolean} [supportsSync] Determines whether sync is supported.
         * @param {boolean} [supportsPersistentIdentifier] Determines whether the device supports a unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsCapabilities(id: string, playableMediaTypes?: string, supportedCommands?: string, supportsMediaControl?: boolean, supportsSync?: boolean, supportsPersistentIdentifier?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionsServiceApiAxiosParamCreator(configuration).postSessionsCapabilities(id, playableMediaTypes, supportedCommands, supportsMediaControl, supportsSync, supportsPersistentIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Updates capabilities for a device
         * @param {ClientCapabilities} body ClientCapabilities: 
         * @param {string} id Session Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsCapabilitiesFull(body: ClientCapabilities, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionsServiceApiAxiosParamCreator(configuration).postSessionsCapabilitiesFull(body, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports that a session has ended
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSessionsLogout(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionsServiceApiAxiosParamCreator(configuration).postSessionsLogout(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SessionsServiceApi - factory interface
 * @export
 */
export const SessionsServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Requires authentication as administrator
         * @param {string} key Auth Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthKeysByKey(key: string, options?: any): AxiosPromise<void> {
            return SessionsServiceApiFp(configuration).deleteAuthKeysByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Removes an additional user from a session
         * @param {string} id Session Id
         * @param {string} userId UserId Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionsByIdUsersByUserid(id: string, userId: string, options?: any): AxiosPromise<void> {
            return SessionsServiceApiFp(configuration).deleteSessionsByIdUsersByUserid(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthKeys(options?: any): AxiosPromise<void> {
            return SessionsServiceApiFp(configuration).getAuthKeys(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthProviders(options?: any): AxiosPromise<Array<NameIdPair>> {
            return SessionsServiceApiFp(configuration).getAuthProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets a list of sessions
         * @param {string} [controllableByUserId] Optional. Filter by sessions that a given user is allowed to remote control.
         * @param {string} [deviceId] Optional. Filter by device id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(controllableByUserId?: string, deviceId?: string, options?: any): AxiosPromise<Array<SessionSessionInfo>> {
            return SessionsServiceApiFp(configuration).getSessions(controllableByUserId, deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @param {string} app App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthKeys(app: string, options?: any): AxiosPromise<void> {
            return SessionsServiceApiFp(configuration).postAuthKeys(app, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {GeneralCommand} body GeneralCommand: 
         * @param {string} id Session Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdCommand(body: GeneralCommand, id: string, options?: any): AxiosPromise<void> {
            return SessionsServiceApiFp(configuration).postSessionsByIdCommand(body, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {string} id Session Id
         * @param {string} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdCommandByCommand(id: string, command: string, options?: any): AxiosPromise<void> {
            return SessionsServiceApiFp(configuration).postSessionsByIdCommandByCommand(id, command, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Issues a command to a client to display a message to the user
         * @param {string} id Session Id
         * @param {string} text The message text.
         * @param {string} header The message header.
         * @param {number} [timeoutMs] The message timeout. If omitted the user will have to confirm viewing the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdMessage(id: string, text: string, header: string, timeoutMs?: number, options?: any): AxiosPromise<void> {
            return SessionsServiceApiFp(configuration).postSessionsByIdMessage(id, text, header, timeoutMs, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Instructs a session to play an item
         * @param {PlayRequest} body PlayRequest: 
         * @param {Array&lt;number&gt;} itemIds The ids of the items to play, comma delimited
         * @param {string} playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
         * @param {string} id Session Id
         * @param {number} [startPositionTicks] The starting position of the first item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdPlaying(body: PlayRequest, itemIds: Array<number>, playCommand: string, id: string, startPositionTicks?: number, options?: any): AxiosPromise<void> {
            return SessionsServiceApiFp(configuration).postSessionsByIdPlaying(body, itemIds, playCommand, id, startPositionTicks, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Issues a playstate command to a client
         * @param {PlaystateRequest} body PlaystateRequest: 
         * @param {string} id Session Id
         * @param {string} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdPlayingByCommand(body: PlaystateRequest, id: string, command: string, options?: any): AxiosPromise<void> {
            return SessionsServiceApiFp(configuration).postSessionsByIdPlayingByCommand(body, id, command, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Issues a system command to a client
         * @param {string} id Session Id
         * @param {string} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdSystemByCommand(id: string, command: string, options?: any): AxiosPromise<void> {
            return SessionsServiceApiFp(configuration).postSessionsByIdSystemByCommand(id, command, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Adds an additional user to a session
         * @param {string} id Session Id
         * @param {string} userId UserId Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdUsersByUserid(id: string, userId: string, options?: any): AxiosPromise<void> {
            return SessionsServiceApiFp(configuration).postSessionsByIdUsersByUserid(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Instructs a session to browse to an item or view
         * @param {string} id Session Id
         * @param {string} itemType The type of item to browse to.
         * @param {string} itemId The Id of the item.
         * @param {string} itemName The name of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsByIdViewing(id: string, itemType: string, itemId: string, itemName: string, options?: any): AxiosPromise<void> {
            return SessionsServiceApiFp(configuration).postSessionsByIdViewing(id, itemType, itemId, itemName, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Updates capabilities for a device
         * @param {string} id Session Id
         * @param {string} [playableMediaTypes] A list of playable media types, comma delimited. Audio, Video, Book, Game, Photo.
         * @param {string} [supportedCommands] A list of supported remote control commands, comma delimited
         * @param {boolean} [supportsMediaControl] Determines whether media can be played remotely.
         * @param {boolean} [supportsSync] Determines whether sync is supported.
         * @param {boolean} [supportsPersistentIdentifier] Determines whether the device supports a unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsCapabilities(id: string, playableMediaTypes?: string, supportedCommands?: string, supportsMediaControl?: boolean, supportsSync?: boolean, supportsPersistentIdentifier?: boolean, options?: any): AxiosPromise<void> {
            return SessionsServiceApiFp(configuration).postSessionsCapabilities(id, playableMediaTypes, supportedCommands, supportsMediaControl, supportsSync, supportsPersistentIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Updates capabilities for a device
         * @param {ClientCapabilities} body ClientCapabilities: 
         * @param {string} id Session Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsCapabilitiesFull(body: ClientCapabilities, id: string, options?: any): AxiosPromise<void> {
            return SessionsServiceApiFp(configuration).postSessionsCapabilitiesFull(body, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Reports that a session has ended
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSessionsLogout(options?: any): AxiosPromise<void> {
            return SessionsServiceApiFp(configuration).postSessionsLogout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsServiceApi - object-oriented interface
 * @export
 * @class SessionsServiceApi
 * @extends {BaseAPI}
 */
export class SessionsServiceApi extends BaseAPI {
    /**
     * Requires authentication as administrator
     * @param {string} key Auth Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    public deleteAuthKeysByKey(key: string, options?: any) {
        return SessionsServiceApiFp(this.configuration).deleteAuthKeysByKey(key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Removes an additional user from a session
     * @param {string} id Session Id
     * @param {string} userId UserId Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    public deleteSessionsByIdUsersByUserid(id: string, userId: string, options?: any) {
        return SessionsServiceApiFp(this.configuration).deleteSessionsByIdUsersByUserid(id, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    public getAuthKeys(options?: any) {
        return SessionsServiceApiFp(this.configuration).getAuthKeys(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    public getAuthProviders(options?: any) {
        return SessionsServiceApiFp(this.configuration).getAuthProviders(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets a list of sessions
     * @param {string} [controllableByUserId] Optional. Filter by sessions that a given user is allowed to remote control.
     * @param {string} [deviceId] Optional. Filter by device id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    public getSessions(controllableByUserId?: string, deviceId?: string, options?: any) {
        return SessionsServiceApiFp(this.configuration).getSessions(controllableByUserId, deviceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @param {string} app App
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    public postAuthKeys(app: string, options?: any) {
        return SessionsServiceApiFp(this.configuration).postAuthKeys(app, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Issues a system command to a client
     * @param {GeneralCommand} body GeneralCommand: 
     * @param {string} id Session Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    public postSessionsByIdCommand(body: GeneralCommand, id: string, options?: any) {
        return SessionsServiceApiFp(this.configuration).postSessionsByIdCommand(body, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Issues a system command to a client
     * @param {string} id Session Id
     * @param {string} command The command to send.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    public postSessionsByIdCommandByCommand(id: string, command: string, options?: any) {
        return SessionsServiceApiFp(this.configuration).postSessionsByIdCommandByCommand(id, command, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Issues a command to a client to display a message to the user
     * @param {string} id Session Id
     * @param {string} text The message text.
     * @param {string} header The message header.
     * @param {number} [timeoutMs] The message timeout. If omitted the user will have to confirm viewing the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    public postSessionsByIdMessage(id: string, text: string, header: string, timeoutMs?: number, options?: any) {
        return SessionsServiceApiFp(this.configuration).postSessionsByIdMessage(id, text, header, timeoutMs, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Instructs a session to play an item
     * @param {PlayRequest} body PlayRequest: 
     * @param {Array&lt;number&gt;} itemIds The ids of the items to play, comma delimited
     * @param {string} playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
     * @param {string} id Session Id
     * @param {number} [startPositionTicks] The starting position of the first item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    public postSessionsByIdPlaying(body: PlayRequest, itemIds: Array<number>, playCommand: string, id: string, startPositionTicks?: number, options?: any) {
        return SessionsServiceApiFp(this.configuration).postSessionsByIdPlaying(body, itemIds, playCommand, id, startPositionTicks, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Issues a playstate command to a client
     * @param {PlaystateRequest} body PlaystateRequest: 
     * @param {string} id Session Id
     * @param {string} command 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    public postSessionsByIdPlayingByCommand(body: PlaystateRequest, id: string, command: string, options?: any) {
        return SessionsServiceApiFp(this.configuration).postSessionsByIdPlayingByCommand(body, id, command, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Issues a system command to a client
     * @param {string} id Session Id
     * @param {string} command The command to send.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    public postSessionsByIdSystemByCommand(id: string, command: string, options?: any) {
        return SessionsServiceApiFp(this.configuration).postSessionsByIdSystemByCommand(id, command, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Adds an additional user to a session
     * @param {string} id Session Id
     * @param {string} userId UserId Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    public postSessionsByIdUsersByUserid(id: string, userId: string, options?: any) {
        return SessionsServiceApiFp(this.configuration).postSessionsByIdUsersByUserid(id, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Instructs a session to browse to an item or view
     * @param {string} id Session Id
     * @param {string} itemType The type of item to browse to.
     * @param {string} itemId The Id of the item.
     * @param {string} itemName The name of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    public postSessionsByIdViewing(id: string, itemType: string, itemId: string, itemName: string, options?: any) {
        return SessionsServiceApiFp(this.configuration).postSessionsByIdViewing(id, itemType, itemId, itemName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Updates capabilities for a device
     * @param {string} id Session Id
     * @param {string} [playableMediaTypes] A list of playable media types, comma delimited. Audio, Video, Book, Game, Photo.
     * @param {string} [supportedCommands] A list of supported remote control commands, comma delimited
     * @param {boolean} [supportsMediaControl] Determines whether media can be played remotely.
     * @param {boolean} [supportsSync] Determines whether sync is supported.
     * @param {boolean} [supportsPersistentIdentifier] Determines whether the device supports a unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    public postSessionsCapabilities(id: string, playableMediaTypes?: string, supportedCommands?: string, supportsMediaControl?: boolean, supportsSync?: boolean, supportsPersistentIdentifier?: boolean, options?: any) {
        return SessionsServiceApiFp(this.configuration).postSessionsCapabilities(id, playableMediaTypes, supportedCommands, supportsMediaControl, supportsSync, supportsPersistentIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Updates capabilities for a device
     * @param {ClientCapabilities} body ClientCapabilities: 
     * @param {string} id Session Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    public postSessionsCapabilitiesFull(body: ClientCapabilities, id: string, options?: any) {
        return SessionsServiceApiFp(this.configuration).postSessionsCapabilitiesFull(body, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Reports that a session has ended
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsServiceApi
     */
    public postSessionsLogout(options?: any) {
        return SessionsServiceApiFp(this.configuration).postSessionsLogout(options).then((request) => request(this.axios, this.basePath));
    }
}
