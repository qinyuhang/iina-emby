/* tslint:disable */
/* eslint-disable */
/**
 * Emby Server API
 * Explore the Emby Server API
 *
 * OpenAPI spec version: 4.6.7.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { AllThemeMediaResult } from '../models';
import { BaseItemDto } from '../models';
import { ItemCounts } from '../models';
import { LibraryDeleteInfo } from '../models';
import { LibraryLibraryOptionsResult } from '../models';
import { LibraryMediaFolder } from '../models';
import { LibraryPostUpdatedMedia } from '../models';
import { QueryResultBaseItemDto } from '../models';
import { ThemeMediaResult } from '../models';
/**
 * LibraryServiceApi - axios parameter creator
 * @export
 */
export const LibraryServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Requires authentication as user
         * @summary Deletes an item from the library and file system
         * @param {string} ids Ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItems: async (ids: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling deleteItems.');
            }
            const localVarPath = `/Items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (ids !== undefined) {
                localVarQueryParameter['Ids'] = ids;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Deletes an item from the library and file system
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteItemsById.');
            }
            const localVarPath = `/Items/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Finds albums similar to a given album.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumsByIdSimilar: async (id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAlbumsByIdSimilar.');
            }
            const localVarPath = `/Albums/{Id}/Similar`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['IncludeItemTypes'] = includeItemTypes;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['EnableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['EnableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['ImageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['EnableImageTypes'] = enableImageTypes;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['Fields'] = fields;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Finds albums similar to a given album.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistsByIdSimilar: async (id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getArtistsByIdSimilar.');
            }
            const localVarPath = `/Artists/{Id}/Similar`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['IncludeItemTypes'] = includeItemTypes;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['EnableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['EnableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['ImageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['EnableImageTypes'] = enableImageTypes;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['Fields'] = fields;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Finds games similar to a given game.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGamesByIdSimilar: async (id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getGamesByIdSimilar.');
            }
            const localVarPath = `/Games/{Id}/Similar`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['IncludeItemTypes'] = includeItemTypes;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['EnableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['EnableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['ImageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['EnableImageTypes'] = enableImageTypes;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['Fields'] = fields;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets all parents of an item
         * @param {string} id Item Id
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdAncestors: async (id: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getItemsByIdAncestors.');
            }
            const localVarPath = `/Items/{Id}/Ancestors`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets critic reviews for an item
         * @param {string} id Item Id
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdCriticreviews: async (id: string, startIndex?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getItemsByIdCriticreviews.');
            }
            const localVarPath = `/Items/{Id}/CriticReviews`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (startIndex !== undefined) {
                localVarQueryParameter['StartIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets delete info for an item
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdDeleteinfo: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getItemsByIdDeleteinfo.');
            }
            const localVarPath = `/Items/{Id}/DeleteInfo`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Downloads item media
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdDownload: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getItemsByIdDownload.');
            }
            const localVarPath = `/Items/{Id}/Download`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets the original file of an item
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdFile: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getItemsByIdFile.');
            }
            const localVarPath = `/Items/{Id}/File`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets similar items
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdSimilar: async (id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getItemsByIdSimilar.');
            }
            const localVarPath = `/Items/{Id}/Similar`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['IncludeItemTypes'] = includeItemTypes;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['EnableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['EnableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['ImageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['EnableImageTypes'] = enableImageTypes;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['Fields'] = fields;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets theme videos and songs for an item
         * @param {string} id Item Id
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {boolean} [inheritFromParent] Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdThememedia: async (id: string, userId?: string, inheritFromParent?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getItemsByIdThememedia.');
            }
            const localVarPath = `/Items/{Id}/ThemeMedia`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (inheritFromParent !== undefined) {
                localVarQueryParameter['InheritFromParent'] = inheritFromParent;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets theme songs for an item
         * @param {string} id Item Id
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {boolean} [inheritFromParent] Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdThemesongs: async (id: string, userId?: string, inheritFromParent?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getItemsByIdThemesongs.');
            }
            const localVarPath = `/Items/{Id}/ThemeSongs`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (inheritFromParent !== undefined) {
                localVarQueryParameter['InheritFromParent'] = inheritFromParent;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets theme videos for an item
         * @param {string} id Item Id
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {boolean} [inheritFromParent] Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdThemevideos: async (id: string, userId?: string, inheritFromParent?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getItemsByIdThemevideos.');
            }
            const localVarPath = `/Items/{Id}/ThemeVideos`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (inheritFromParent !== undefined) {
                localVarQueryParameter['InheritFromParent'] = inheritFromParent;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @param {string} [userId] Optional. Get counts from a specific user&#x27;s library.
         * @param {boolean} [isFavorite] Optional. Get counts of favorite items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsCounts: async (userId?: string, isFavorite?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Items/Counts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['IsFavorite'] = isFavorite;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibrariesAvailableoptions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Libraries/AvailableOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets all user media folders.
         * @param {boolean} [isHidden] Optional. Filter by folders that are marked hidden, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryMediafolders: async (isHidden?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/MediaFolders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (isHidden !== undefined) {
                localVarQueryParameter['IsHidden'] = isHidden;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets a list of physical paths from virtual folders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryPhysicalpaths: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/PhysicalPaths`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets all user media folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibrarySelectablemediafolders: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/SelectableMediaFolders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Finds movies and trailers similar to a given movie.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMoviesByIdSimilar: async (id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getMoviesByIdSimilar.');
            }
            const localVarPath = `/Movies/{Id}/Similar`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['IncludeItemTypes'] = includeItemTypes;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['EnableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['EnableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['ImageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['EnableImageTypes'] = enableImageTypes;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['Fields'] = fields;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Finds tv shows similar to a given one.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShowsByIdSimilar: async (id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getShowsByIdSimilar.');
            }
            const localVarPath = `/Shows/{Id}/Similar`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['IncludeItemTypes'] = includeItemTypes;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['EnableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['EnableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['ImageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['EnableImageTypes'] = enableImageTypes;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['Fields'] = fields;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Finds movies and trailers similar to a given trailer.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrailersByIdSimilar: async (id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTrailersByIdSimilar.');
            }
            const localVarPath = `/Trailers/{Id}/Similar`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['IncludeItemTypes'] = includeItemTypes;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['EnableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['EnableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['ImageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['EnableImageTypes'] = enableImageTypes;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['Limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['Fields'] = fields;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports that new movies have been added by an external source
         * @param {LibraryPostUpdatedMedia} body PostUpdatedMedia
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLibraryMediaUpdated: async (body: LibraryPostUpdatedMedia, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postLibraryMediaUpdated.');
            }
            const localVarPath = `/Library/Media/Updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Deprecated. Use /Library/Media/Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLibraryMoviesAdded: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Movies/Added`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Deprecated. Use /Library/Media/Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLibraryMoviesUpdated: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Movies/Updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Starts a library scan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLibraryRefresh: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Deprecated. Use /Library/Media/Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLibrarySeriesAdded: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Series/Added`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires authentication as user
         * @summary Deprecated. Use /Library/Media/Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLibrarySeriesUpdated: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Series/Updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikeyauth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("api_key")
                    : await configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            // authentication embyauth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LibraryServiceApi - functional programming interface
 * @export
 */
export const LibraryServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Requires authentication as user
         * @summary Deletes an item from the library and file system
         * @param {string} ids Ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItems(ids: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).deleteItems(ids, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Deletes an item from the library and file system
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemsById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).deleteItemsById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Finds albums similar to a given album.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumsByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultBaseItemDto>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getAlbumsByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Finds albums similar to a given album.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtistsByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultBaseItemDto>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getArtistsByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Finds games similar to a given game.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGamesByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultBaseItemDto>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getGamesByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets all parents of an item
         * @param {string} id Item Id
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByIdAncestors(id: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseItemDto>>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getItemsByIdAncestors(id, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets critic reviews for an item
         * @param {string} id Item Id
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByIdCriticreviews(id: string, startIndex?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultBaseItemDto>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getItemsByIdCriticreviews(id, startIndex, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets delete info for an item
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByIdDeleteinfo(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryDeleteInfo>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getItemsByIdDeleteinfo(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Downloads item media
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByIdDownload(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getItemsByIdDownload(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets the original file of an item
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByIdFile(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getItemsByIdFile(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets similar items
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultBaseItemDto>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getItemsByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets theme videos and songs for an item
         * @param {string} id Item Id
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {boolean} [inheritFromParent] Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByIdThememedia(id: string, userId?: string, inheritFromParent?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllThemeMediaResult>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getItemsByIdThememedia(id, userId, inheritFromParent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets theme songs for an item
         * @param {string} id Item Id
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {boolean} [inheritFromParent] Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByIdThemesongs(id: string, userId?: string, inheritFromParent?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeMediaResult>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getItemsByIdThemesongs(id, userId, inheritFromParent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets theme videos for an item
         * @param {string} id Item Id
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {boolean} [inheritFromParent] Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByIdThemevideos(id: string, userId?: string, inheritFromParent?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeMediaResult>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getItemsByIdThemevideos(id, userId, inheritFromParent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @param {string} [userId] Optional. Get counts from a specific user&#x27;s library.
         * @param {boolean} [isFavorite] Optional. Get counts of favorite items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsCounts(userId?: string, isFavorite?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemCounts>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getItemsCounts(userId, isFavorite, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLibrariesAvailableoptions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryLibraryOptionsResult>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getLibrariesAvailableoptions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets all user media folders.
         * @param {boolean} [isHidden] Optional. Filter by folders that are marked hidden, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryMediafolders(isHidden?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultBaseItemDto>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getLibraryMediafolders(isHidden, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Gets a list of physical paths from virtual folders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryPhysicalpaths(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getLibraryPhysicalpaths(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Gets all user media folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLibrarySelectablemediafolders(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LibraryMediaFolder>>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getLibrarySelectablemediafolders(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Finds movies and trailers similar to a given movie.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMoviesByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultBaseItemDto>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getMoviesByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Finds tv shows similar to a given one.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShowsByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultBaseItemDto>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getShowsByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Finds movies and trailers similar to a given trailer.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrailersByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResultBaseItemDto>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).getTrailersByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Reports that new movies have been added by an external source
         * @param {LibraryPostUpdatedMedia} body PostUpdatedMedia
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLibraryMediaUpdated(body: LibraryPostUpdatedMedia, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).postLibraryMediaUpdated(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Deprecated. Use /Library/Media/Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLibraryMoviesAdded(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).postLibraryMoviesAdded(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Deprecated. Use /Library/Media/Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLibraryMoviesUpdated(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).postLibraryMoviesUpdated(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as administrator
         * @summary Starts a library scan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLibraryRefresh(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).postLibraryRefresh(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Deprecated. Use /Library/Media/Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLibrarySeriesAdded(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).postLibrarySeriesAdded(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Requires authentication as user
         * @summary Deprecated. Use /Library/Media/Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLibrarySeriesUpdated(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryServiceApiAxiosParamCreator(configuration).postLibrarySeriesUpdated(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LibraryServiceApi - factory interface
 * @export
 */
export const LibraryServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Requires authentication as user
         * @summary Deletes an item from the library and file system
         * @param {string} ids Ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItems(ids: string, options?: any): AxiosPromise<void> {
            return LibraryServiceApiFp(configuration).deleteItems(ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Deletes an item from the library and file system
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsById(id: string, options?: any): AxiosPromise<void> {
            return LibraryServiceApiFp(configuration).deleteItemsById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Finds albums similar to a given album.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumsByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<QueryResultBaseItemDto> {
            return LibraryServiceApiFp(configuration).getAlbumsByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Finds albums similar to a given album.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistsByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<QueryResultBaseItemDto> {
            return LibraryServiceApiFp(configuration).getArtistsByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Finds games similar to a given game.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGamesByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<QueryResultBaseItemDto> {
            return LibraryServiceApiFp(configuration).getGamesByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets all parents of an item
         * @param {string} id Item Id
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdAncestors(id: string, userId?: string, options?: any): AxiosPromise<Array<BaseItemDto>> {
            return LibraryServiceApiFp(configuration).getItemsByIdAncestors(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets critic reviews for an item
         * @param {string} id Item Id
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdCriticreviews(id: string, startIndex?: number, limit?: number, options?: any): AxiosPromise<QueryResultBaseItemDto> {
            return LibraryServiceApiFp(configuration).getItemsByIdCriticreviews(id, startIndex, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets delete info for an item
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdDeleteinfo(id: string, options?: any): AxiosPromise<LibraryDeleteInfo> {
            return LibraryServiceApiFp(configuration).getItemsByIdDeleteinfo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Downloads item media
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdDownload(id: string, options?: any): AxiosPromise<void> {
            return LibraryServiceApiFp(configuration).getItemsByIdDownload(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets the original file of an item
         * @param {string} id Item Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdFile(id: string, options?: any): AxiosPromise<void> {
            return LibraryServiceApiFp(configuration).getItemsByIdFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets similar items
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<QueryResultBaseItemDto> {
            return LibraryServiceApiFp(configuration).getItemsByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets theme videos and songs for an item
         * @param {string} id Item Id
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {boolean} [inheritFromParent] Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdThememedia(id: string, userId?: string, inheritFromParent?: boolean, options?: any): AxiosPromise<AllThemeMediaResult> {
            return LibraryServiceApiFp(configuration).getItemsByIdThememedia(id, userId, inheritFromParent, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets theme songs for an item
         * @param {string} id Item Id
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {boolean} [inheritFromParent] Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdThemesongs(id: string, userId?: string, inheritFromParent?: boolean, options?: any): AxiosPromise<ThemeMediaResult> {
            return LibraryServiceApiFp(configuration).getItemsByIdThemesongs(id, userId, inheritFromParent, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets theme videos for an item
         * @param {string} id Item Id
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {boolean} [inheritFromParent] Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByIdThemevideos(id: string, userId?: string, inheritFromParent?: boolean, options?: any): AxiosPromise<ThemeMediaResult> {
            return LibraryServiceApiFp(configuration).getItemsByIdThemevideos(id, userId, inheritFromParent, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @param {string} [userId] Optional. Get counts from a specific user&#x27;s library.
         * @param {boolean} [isFavorite] Optional. Get counts of favorite items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsCounts(userId?: string, isFavorite?: boolean, options?: any): AxiosPromise<ItemCounts> {
            return LibraryServiceApiFp(configuration).getItemsCounts(userId, isFavorite, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibrariesAvailableoptions(options?: any): AxiosPromise<LibraryLibraryOptionsResult> {
            return LibraryServiceApiFp(configuration).getLibrariesAvailableoptions(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets all user media folders.
         * @param {boolean} [isHidden] Optional. Filter by folders that are marked hidden, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryMediafolders(isHidden?: boolean, options?: any): AxiosPromise<QueryResultBaseItemDto> {
            return LibraryServiceApiFp(configuration).getLibraryMediafolders(isHidden, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Gets a list of physical paths from virtual folders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryPhysicalpaths(options?: any): AxiosPromise<Array<string>> {
            return LibraryServiceApiFp(configuration).getLibraryPhysicalpaths(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Gets all user media folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibrarySelectablemediafolders(options?: any): AxiosPromise<Array<LibraryMediaFolder>> {
            return LibraryServiceApiFp(configuration).getLibrarySelectablemediafolders(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Finds movies and trailers similar to a given movie.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMoviesByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<QueryResultBaseItemDto> {
            return LibraryServiceApiFp(configuration).getMoviesByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Finds tv shows similar to a given one.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShowsByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<QueryResultBaseItemDto> {
            return LibraryServiceApiFp(configuration).getShowsByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Finds movies and trailers similar to a given trailer.
         * @param {string} id Item Id
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableImages] Optional, include image information in output
         * @param {boolean} [enableUserData] Optional, include user data
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] Optional. Filter by user id, and attach user data
         * @param {number} [limit] Optional. The maximum number of records to return
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrailersByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<QueryResultBaseItemDto> {
            return LibraryServiceApiFp(configuration).getTrailersByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Reports that new movies have been added by an external source
         * @param {LibraryPostUpdatedMedia} body PostUpdatedMedia
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLibraryMediaUpdated(body: LibraryPostUpdatedMedia, options?: any): AxiosPromise<void> {
            return LibraryServiceApiFp(configuration).postLibraryMediaUpdated(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Deprecated. Use /Library/Media/Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLibraryMoviesAdded(options?: any): AxiosPromise<void> {
            return LibraryServiceApiFp(configuration).postLibraryMoviesAdded(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Deprecated. Use /Library/Media/Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLibraryMoviesUpdated(options?: any): AxiosPromise<void> {
            return LibraryServiceApiFp(configuration).postLibraryMoviesUpdated(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as administrator
         * @summary Starts a library scan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLibraryRefresh(options?: any): AxiosPromise<void> {
            return LibraryServiceApiFp(configuration).postLibraryRefresh(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Deprecated. Use /Library/Media/Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLibrarySeriesAdded(options?: any): AxiosPromise<void> {
            return LibraryServiceApiFp(configuration).postLibrarySeriesAdded(options).then((request) => request(axios, basePath));
        },
        /**
         * Requires authentication as user
         * @summary Deprecated. Use /Library/Media/Updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLibrarySeriesUpdated(options?: any): AxiosPromise<void> {
            return LibraryServiceApiFp(configuration).postLibrarySeriesUpdated(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LibraryServiceApi - object-oriented interface
 * @export
 * @class LibraryServiceApi
 * @extends {BaseAPI}
 */
export class LibraryServiceApi extends BaseAPI {
    /**
     * Requires authentication as user
     * @summary Deletes an item from the library and file system
     * @param {string} ids Ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public deleteItems(ids: string, options?: any) {
        return LibraryServiceApiFp(this.configuration).deleteItems(ids, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Deletes an item from the library and file system
     * @param {string} id Item Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public deleteItemsById(id: string, options?: any) {
        return LibraryServiceApiFp(this.configuration).deleteItemsById(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Finds albums similar to a given album.
     * @param {string} id Item Id
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [userId] Optional. Filter by user id, and attach user data
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getAlbumsByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any) {
        return LibraryServiceApiFp(this.configuration).getAlbumsByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Finds albums similar to a given album.
     * @param {string} id Item Id
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [userId] Optional. Filter by user id, and attach user data
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getArtistsByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any) {
        return LibraryServiceApiFp(this.configuration).getArtistsByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Finds games similar to a given game.
     * @param {string} id Item Id
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [userId] Optional. Filter by user id, and attach user data
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getGamesByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any) {
        return LibraryServiceApiFp(this.configuration).getGamesByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets all parents of an item
     * @param {string} id Item Id
     * @param {string} [userId] Optional. Filter by user id, and attach user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getItemsByIdAncestors(id: string, userId?: string, options?: any) {
        return LibraryServiceApiFp(this.configuration).getItemsByIdAncestors(id, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets critic reviews for an item
     * @param {string} id Item Id
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getItemsByIdCriticreviews(id: string, startIndex?: number, limit?: number, options?: any) {
        return LibraryServiceApiFp(this.configuration).getItemsByIdCriticreviews(id, startIndex, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets delete info for an item
     * @param {string} id Item Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getItemsByIdDeleteinfo(id: string, options?: any) {
        return LibraryServiceApiFp(this.configuration).getItemsByIdDeleteinfo(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Downloads item media
     * @param {string} id Item Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getItemsByIdDownload(id: string, options?: any) {
        return LibraryServiceApiFp(this.configuration).getItemsByIdDownload(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets the original file of an item
     * @param {string} id Item Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getItemsByIdFile(id: string, options?: any) {
        return LibraryServiceApiFp(this.configuration).getItemsByIdFile(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets similar items
     * @param {string} id Item Id
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [userId] Optional. Filter by user id, and attach user data
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getItemsByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any) {
        return LibraryServiceApiFp(this.configuration).getItemsByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets theme videos and songs for an item
     * @param {string} id Item Id
     * @param {string} [userId] Optional. Filter by user id, and attach user data
     * @param {boolean} [inheritFromParent] Determines whether or not parent items should be searched for theme media.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getItemsByIdThememedia(id: string, userId?: string, inheritFromParent?: boolean, options?: any) {
        return LibraryServiceApiFp(this.configuration).getItemsByIdThememedia(id, userId, inheritFromParent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets theme songs for an item
     * @param {string} id Item Id
     * @param {string} [userId] Optional. Filter by user id, and attach user data
     * @param {boolean} [inheritFromParent] Determines whether or not parent items should be searched for theme media.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getItemsByIdThemesongs(id: string, userId?: string, inheritFromParent?: boolean, options?: any) {
        return LibraryServiceApiFp(this.configuration).getItemsByIdThemesongs(id, userId, inheritFromParent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets theme videos for an item
     * @param {string} id Item Id
     * @param {string} [userId] Optional. Filter by user id, and attach user data
     * @param {boolean} [inheritFromParent] Determines whether or not parent items should be searched for theme media.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getItemsByIdThemevideos(id: string, userId?: string, inheritFromParent?: boolean, options?: any) {
        return LibraryServiceApiFp(this.configuration).getItemsByIdThemevideos(id, userId, inheritFromParent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @param {string} [userId] Optional. Get counts from a specific user&#x27;s library.
     * @param {boolean} [isFavorite] Optional. Get counts of favorite items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getItemsCounts(userId?: string, isFavorite?: boolean, options?: any) {
        return LibraryServiceApiFp(this.configuration).getItemsCounts(userId, isFavorite, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getLibrariesAvailableoptions(options?: any) {
        return LibraryServiceApiFp(this.configuration).getLibrariesAvailableoptions(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets all user media folders.
     * @param {boolean} [isHidden] Optional. Filter by folders that are marked hidden, or not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getLibraryMediafolders(isHidden?: boolean, options?: any) {
        return LibraryServiceApiFp(this.configuration).getLibraryMediafolders(isHidden, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Gets a list of physical paths from virtual folders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getLibraryPhysicalpaths(options?: any) {
        return LibraryServiceApiFp(this.configuration).getLibraryPhysicalpaths(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Gets all user media folders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getLibrarySelectablemediafolders(options?: any) {
        return LibraryServiceApiFp(this.configuration).getLibrarySelectablemediafolders(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Finds movies and trailers similar to a given movie.
     * @param {string} id Item Id
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [userId] Optional. Filter by user id, and attach user data
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getMoviesByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any) {
        return LibraryServiceApiFp(this.configuration).getMoviesByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Finds tv shows similar to a given one.
     * @param {string} id Item Id
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [userId] Optional. Filter by user id, and attach user data
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getShowsByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any) {
        return LibraryServiceApiFp(this.configuration).getShowsByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Finds movies and trailers similar to a given trailer.
     * @param {string} id Item Id
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {boolean} [enableImages] Optional, include image information in output
     * @param {boolean} [enableUserData] Optional, include user data
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [userId] Optional. Filter by user id, and attach user data
     * @param {number} [limit] Optional. The maximum number of records to return
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public getTrailersByIdSimilar(id: string, includeItemTypes?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, limit?: number, fields?: string, options?: any) {
        return LibraryServiceApiFp(this.configuration).getTrailersByIdSimilar(id, includeItemTypes, enableImages, enableUserData, imageTypeLimit, enableImageTypes, userId, limit, fields, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Reports that new movies have been added by an external source
     * @param {LibraryPostUpdatedMedia} body PostUpdatedMedia
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public postLibraryMediaUpdated(body: LibraryPostUpdatedMedia, options?: any) {
        return LibraryServiceApiFp(this.configuration).postLibraryMediaUpdated(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Deprecated. Use /Library/Media/Updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public postLibraryMoviesAdded(options?: any) {
        return LibraryServiceApiFp(this.configuration).postLibraryMoviesAdded(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Deprecated. Use /Library/Media/Updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public postLibraryMoviesUpdated(options?: any) {
        return LibraryServiceApiFp(this.configuration).postLibraryMoviesUpdated(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as administrator
     * @summary Starts a library scan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public postLibraryRefresh(options?: any) {
        return LibraryServiceApiFp(this.configuration).postLibraryRefresh(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Deprecated. Use /Library/Media/Updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public postLibrarySeriesAdded(options?: any) {
        return LibraryServiceApiFp(this.configuration).postLibrarySeriesAdded(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires authentication as user
     * @summary Deprecated. Use /Library/Media/Updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryServiceApi
     */
    public postLibrarySeriesUpdated(options?: any) {
        return LibraryServiceApiFp(this.configuration).postLibrarySeriesUpdated(options).then((request) => request(this.axios, this.basePath));
    }
}
